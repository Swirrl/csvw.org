{
  "version": 3,
  "sources": ["../../build/_snowpack/pkg/common/codegen-df7bb22c.js", "../../build/_snowpack/pkg/common/distsq-d74f45eb.js", "../../build/_snowpack/pkg/common/set-c051c4f9.js", "../../build/_snowpack/pkg/common/add-5cc35f4d.js", "../../build/_snowpack/pkg/common/index-e6512bd8.js", "../../build/_snowpack/pkg/@thi.ng/geom-voronoi.js", "../../build/_snowpack/pkg/common/ensure-array-575b2a26.js", "../../build/_snowpack/pkg/common/random-15d3d7f2.js", "../../build/_snowpack/pkg/@thi.ng/geom.js", "../../build/_snowpack/pkg/@thi.ng/geom-accel.js", "../../build/_snowpack/pkg/@thi.ng/poisson.js", "../../build/dist/triangulation.js"],
  "sourcesContent": ["const implementsFunction = (x, fn) => x != null && typeof x[fn] === \"function\";\n\nconst isArrayLike = (x) => x != null && typeof x !== \"function\" && x.length !== undefined;\n\nconst isIterable = (x) => x != null && typeof x[Symbol.iterator] === \"function\";\n\nconst defError = (prefix, suffix = (msg) => (msg !== undefined ? \": \" + msg : \"\")) => class extends Error {\n    constructor(msg) {\n        super(prefix(msg) + suffix(msg));\n    }\n};\n\nconst IllegalArityError = defError(() => \"illegal arity\");\nconst illegalArity = (n) => {\n    throw new IllegalArityError(n);\n};\n\nconst UnsupportedOperationError = defError(() => \"unsupported operation\");\nconst unsupported = (msg) => {\n    throw new UnsupportedOperationError(msg);\n};\n\n/**\n * Internal use only. **Do NOT use in user land code!**\n *\n * @internal\n */\nconst SEMAPHORE = Symbol();\n/**\n * No-effect placeholder function.\n */\nconst NO_OP = () => { };\n\nconst ensureTransducer = (x) => implementsFunction(x, \"xform\") ? x.xform() : x;\n\nclass Reduced {\n    constructor(val) {\n        this.value = val;\n    }\n    deref() {\n        return this.value;\n    }\n}\nconst reduced = (x) => new Reduced(x);\nconst isReduced = (x) => x instanceof Reduced;\nconst ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);\nconst unreduced = (x) => (x instanceof Reduced ? x.deref() : x);\n\nconst parseArgs = (args) => args.length === 2\n    ? [undefined, args[1]]\n    : args.length === 3\n        ? [args[1], args[2]]\n        : illegalArity(args.length);\nfunction reduce(...args) {\n    const rfn = args[0];\n    const init = rfn[0];\n    const complete = rfn[1];\n    const reduce = rfn[2];\n    args = parseArgs(args);\n    const acc = args[0] == null ? init() : args[0];\n    const xs = args[1];\n    return unreduced(complete(implementsFunction(xs, \"$reduce\")\n        ? xs.$reduce(reduce, acc)\n        : isArrayLike(xs)\n            ? reduceArray(reduce, acc, xs)\n            : reduceIterable(reduce, acc, xs)));\n}\nconst reduceArray = (rfn, acc, xs) => {\n    for (let i = 0, n = xs.length; i < n; i++) {\n        acc = rfn(acc, xs[i]);\n        if (isReduced(acc)) {\n            acc = acc.deref();\n            break;\n        }\n    }\n    return acc;\n};\nconst reduceIterable = (rfn, acc, xs) => {\n    for (let x of xs) {\n        acc = rfn(acc, x);\n        if (isReduced(acc)) {\n            acc = acc.deref();\n            break;\n        }\n    }\n    return acc;\n};\n/**\n * Convenience helper for building a full {@link Reducer} using the identity\n * function (i.e. `(x) => x`) as completion step (true for 90% of all\n * bundled transducers).\n *\n * @param init - init step of reducer\n * @param rfn - reduction step of reducer\n */\nconst reducer = (init, rfn) => [init, (acc) => acc, rfn];\n\nfunction push(xs) {\n    return xs\n        ? [...xs]\n        : reducer(() => [], (acc, x) => (acc.push(x), acc));\n}\n\n/**\n * Takes a transducer and input iterable. Returns iterator of\n * transformed results.\n *\n * @param xform -\n * @param xs -\n */\nfunction* iterator(xform, xs) {\n    const rfn = ensureTransducer(xform)(push());\n    const complete = rfn[1];\n    const reduce = rfn[2];\n    for (let x of xs) {\n        const y = reduce([], x);\n        if (isReduced(y)) {\n            yield* unreduced(complete(y.deref()));\n            return;\n        }\n        if (y.length) {\n            yield* y;\n        }\n    }\n    yield* unreduced(complete([]));\n}\n/**\n * Optimized version of {@link iterator} for transducers which are\n * guaranteed to:\n *\n * 1) Only produce none or a single result per input\n * 2) Do not require a `completion` reduction step\n *\n * @param xform -\n * @param xs -\n */\nfunction* iterator1(xform, xs) {\n    const reduce = (ensureTransducer(xform)([NO_OP, NO_OP, (_, x) => x]))[2];\n    for (let x of xs) {\n        let y = reduce(SEMAPHORE, x);\n        if (isReduced(y)) {\n            y = unreduced(y.deref());\n            if (y !== SEMAPHORE) {\n                yield y;\n            }\n            return;\n        }\n        if (y !== SEMAPHORE) {\n            yield y;\n        }\n    }\n}\n/**\n * Helper function used by various transducers to wrap themselves as\n * transforming iterators. Delegates to {@link iterator1} by default.\n *\n * @param xform -\n * @param args -\n * @param impl -\n *\n * @internal\n */\nconst $iter = (xform, args, impl = iterator1) => {\n    const n = args.length - 1;\n    return isIterable(args[n])\n        ? args.length > 1\n            ? impl(xform.apply(null, args.slice(0, n)), args[n])\n            : impl(xform(), args[0])\n        : undefined;\n};\n\n/**\n * Reducer composition helper, internally used by various transducers\n * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a\n * reducing function `fn`. Returns a new reducer tuple.\n *\n * @remarks\n * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.\n * `fn` accepts values of type `C` and produces interim results of type\n * `B`, which are then (possibly) passed to the \"inner\" `rfn[2]`\n * function. Therefore the resulting reducer takes inputs of `C` and an\n * accumulator of type `A`.\n *\n * It is assumed that `fn` internally calls `rfn[2]` to pass its own\n * results for further processing by the nested reducer `rfn`.\n *\n * @example\n * ```ts\n * compR(rfn, fn)\n * // [rfn[0], rfn[1], fn]\n * ```\n *\n * @param rfn -\n * @param fn -\n */\nconst compR = (rfn, fn) => [rfn[0], rfn[1], fn];\n\nfunction map(fn, src) {\n    return isIterable(src)\n        ? iterator1(map(fn), src)\n        : (rfn) => {\n            const r = rfn[2];\n            return compR(rfn, (acc, x) => r(acc, fn(x)));\n        };\n}\n\nfunction transduce(...args) {\n    return $transduce(transduce, reduce, args);\n}\nconst $transduce = (tfn, rfn, args) => {\n    let acc, xs;\n    switch (args.length) {\n        case 4:\n            xs = args[3];\n            acc = args[2];\n            break;\n        case 3:\n            xs = args[2];\n            break;\n        case 2:\n            return map((x) => tfn(args[0], args[1], x));\n        default:\n            illegalArity(args.length);\n    }\n    return rfn(ensureTransducer(args[0])(args[1]), acc, xs);\n};\n\nfunction comp(...fns) {\n    let [a, b, c, d, e, f, g, h, i, j] = fns;\n    switch (fns.length) {\n        case 0:\n            illegalArity(0);\n        case 1:\n            return a;\n        case 2:\n            return (...xs) => a(b(...xs));\n        case 3:\n            return (...xs) => a(b(c(...xs)));\n        case 4:\n            return (...xs) => a(b(c(d(...xs))));\n        case 5:\n            return (...xs) => a(b(c(d(e(...xs)))));\n        case 6:\n            return (...xs) => a(b(c(d(e(f(...xs))))));\n        case 7:\n            return (...xs) => a(b(c(d(e(f(g(...xs)))))));\n        case 8:\n            return (...xs) => a(b(c(d(e(f(g(h(...xs))))))));\n        case 9:\n            return (...xs) => a(b(c(d(e(f(g(h(i(...xs)))))))));\n        case 10:\n        default:\n            const fn = (...xs) => a(b(c(d(e(f(g(h(i(j(...xs))))))))));\n            return fns.length === 10 ? fn : comp(fn, ...fns.slice(10));\n    }\n}\n\nfunction str(sep, xs) {\n    sep = sep || \"\";\n    let first = true;\n    return xs\n        ? [...xs].join(sep)\n        : reducer(() => \"\", (acc, x) => ((acc = first ? acc + x : acc + sep + x), (first = false), acc));\n}\n\nfunction range(from, to, step) {\n    return new Range(from, to, step);\n}\n/**\n * Simple class wrapper around given range interval and implementing\n * `Iterable` and {@link IReducible} interfaces, the latter is used to\n * accelerate use with {@link (reduce:1)}.\n */\nclass Range {\n    constructor(from, to, step) {\n        if (from === undefined) {\n            from = 0;\n            to = Infinity;\n        }\n        else if (to === undefined) {\n            to = from;\n            from = 0;\n        }\n        step = step === undefined ? (from < to ? 1 : -1) : step;\n        this.from = from;\n        this.to = to;\n        this.step = step;\n    }\n    *[Symbol.iterator]() {\n        let { from, to, step } = this;\n        if (step > 0) {\n            while (from < to) {\n                yield from;\n                from += step;\n            }\n        }\n        else if (step < 0) {\n            while (from > to) {\n                yield from;\n                from += step;\n            }\n        }\n    }\n    $reduce(rfn, acc) {\n        const step = this.step;\n        if (step > 0) {\n            for (let i = this.from, n = this.to; i < n && !isReduced(acc); i += step) {\n                acc = rfn(acc, i);\n            }\n        }\n        else {\n            for (let i = this.from, n = this.to; i > n && !isReduced(acc); i += step) {\n                acc = rfn(acc, i);\n            }\n        }\n        return acc;\n    }\n}\n\nfunction* zip(...src) {\n    const iters = src.map((s) => s[Symbol.iterator]());\n    while (true) {\n        const tuple = [];\n        for (let i of iters) {\n            let v = i.next();\n            if (v.done) {\n                return;\n            }\n            tuple.push(v.value);\n        }\n        yield tuple;\n    }\n}\n\nconst PI = Math.PI;\nconst TAU = PI * 2;\nconst HALF_PI = PI / 2;\nconst THIRD_PI = PI / 3;\nconst DEG2RAD = PI / 180;\nconst SQRT2 = Math.SQRT2;\nconst SQRT3 = Math.sqrt(3);\nconst SQRT2_2 = SQRT2 / 2;\nlet EPS = 1e-6;\n\nfunction mapIndexed(...args) {\n    return ($iter(mapIndexed, args) ||\n        ((rfn) => {\n            const r = rfn[2];\n            const fn = args[0];\n            let i = args[1] || 0;\n            return compR(rfn, (acc, x) => r(acc, fn(i++, x)));\n        }));\n}\n\nfunction comp$1(...fns) {\n    fns = fns.map(ensureTransducer);\n    return comp.apply(null, fns);\n}\n\nfunction take(n, src) {\n    return isIterable(src)\n        ? iterator(take(n), src)\n        : (rfn) => {\n            const r = rfn[2];\n            let m = n;\n            return compR(rfn, (acc, x) => --m > 0\n                ? r(acc, x)\n                : m === 0\n                    ? ensureReduced(r(acc, x))\n                    : reduced(acc));\n        };\n}\n\n/** @internal */\n// prettier-ignore\nconst MATH = (op) => ([o, a, b]) => `${o}=${a}${op}${b};`;\n/** @internal */\n// prettier-ignore\nconst MATH_N = (op) => ([o, a]) => `${o}=${a}${op}n;`;\n/** @internal */\n// prettier-ignore\nconst MATH2 = (op1, op2) => ([o, a, b, c]) => `${o}=(${a}${op1}${b})${op2}${c};`;\n/** @internal */\n// prettier-ignore\nconst MATH2_N = (op1, op2) => ([o, a, b]) => `${o}=(${a}${op1}${b})${op2}n;`;\n/** @internal */\n// prettier-ignore\nconst MATH2A_N = (op1, op2) => ([o, a, b]) => `${o}=(${a}${op1}n)${op2}${b};`;\n/** @internal */\n// prettier-ignore\nconst FN = (op = \"op\") => ([o, a]) => `${o}=${op}(${a});`;\n/** @internal */\n// prettier-ignore\nconst FN2 = (op = \"op\") => ([o, a, b]) => `${o}=${op}(${a},${b});`;\n/** @internal */\n// prettier-ignore\nconst FN_N = (op = \"op\") => ([o, a]) => `${o}=${op}(${a},n);`;\n/** @internal */\nconst DOT = ([a, b]) => `${a}*${b}`;\n/** @internal */\nconst DOT_G = ([a, b]) => `s+=${a}*${b};`;\n/** @internal */\nconst SET = ([o, a]) => `${o}=${a};`;\n/** @internal */\nconst SET_N = ([a]) => `${a}=n;`;\n/** @internal */\nconst MIX_N = ([o, a, b]) => `${o}=${a}+(${b}-${a})*n;`;\n\n/**\n * Specialized / optimized version of {@link @thi.ng/defmulti# | @thi.ng/defmulti} for\n * vector operations. Uses simplified logic to dispatch on length\n * (vector size) of `dispatch` argument.\n *\n * @param dispatch - arg index\n */\nconst vop = (dispatch = 0) => {\n    const impls = new Array(5);\n    let fallback;\n    const fn = (...args) => {\n        const g = impls[args[dispatch].length] || fallback;\n        return g\n            ? g(...args)\n            : unsupported(`no impl for vec size ${args[dispatch].length}`);\n    };\n    fn.add = (dim, fn) => (impls[dim] = fn);\n    fn.default = (fn) => (fallback = fn);\n    fn.impl = (dim) => impls[dim] || fallback;\n    // fn.impls = impls;\n    return fn;\n};\n\n/** @internal */\nconst ARGS_V = \"o,a\";\n/** @internal */\nconst ARGS_VV = \"o,a,b\";\n/** @internal */\nconst ARGS_VVV = \"o,a,b,c\";\n/** @internal */\nconst ARGS_VN = \"o,a,n\";\n/** @internal */\nconst ARGS_VNV = \"o,a,n,b\";\n/** @internal */\nconst ARGS_VVN = \"o,a,b,n\";\n/** @internal */\nconst SARGS_V = \"io=0,ia=0,so=1,sa=1\";\n/** @internal */\nconst NEW_OUT = \"!o&&(o=[]);\";\n/**\n * HOF array index lookup gen to provide optimized versions of:\n *\n * @example\n * ```ts\n * lookup(\"a\")(0) // a[ia]\n * lookup(\"a\")(1) // a[ia * sa]\n * lookup(\"a\")(2) // a[ia + 2 * sa]\n * ```\n *\n * @param sym -\n */\nconst lookup = (sym) => (i) => i > 1\n    ? `${sym}[i${sym}+${i}*s${sym}]`\n    : i == 1\n        ? `${sym}[i${sym}+s${sym}]`\n        : `${sym}[i${sym}]`;\n/**\n * Infinite iterator of strided index lookups for `sym`.\n *\n * @param sym -\n */\nconst indicesStrided = (sym) => map(lookup(sym), range());\n/**\n * Infinite iterator of simple (non-strided) index lookups for `sym`.\n *\n * @param sym -\n */\nconst indices = (sym) => map((i) => `${sym}[${i}]`, range());\n/**\n * Code generator for loop-unrolled vector operations. Takes a vector\n * size `dim`, a code template function `tpl` and an array of symbol\n * names participating in the template. For each symbol, creates\n * iterator of index lookups (e.g. `a[0]` or `a[ia+k*sa]`), forms them\n * into tuples and passes them to template to generate code and joins\n * generated result with `opJoin` separator (default:\n * `\"\"`).\n *\n * If the optional `ret` arg is not `null` (default `\"a\"`), appends a\n * `return` statement to the result array, using `ret` as return value.\n * Returns array of source code lines.\n *\n * The optional `pre` and `post` strings can be used to wrap the\n * generated code. `post` will be injected **before** the generated\n * return statement (if not suppressed).\n *\n * @param dim -\n * @param tpl -\n * @param syms -\n * @param ret -\n * @param opJoin -\n * @param pre -\n * @param post -\n * @param strided -\n */\nconst assemble = (dim, tpl, syms, ret = \"a\", opJoin = \"\", pre = \"\", post = \"\", strided = false) => [\n    pre,\n    transduce(comp$1(take(dim), mapIndexed((i, x) => tpl(x, i))), str(opJoin), (zip.apply(null, syms.split(\",\").map(strided ? indicesStrided : indices)))),\n    post,\n    ret !== \"\" ? `return ${ret};` : \"\",\n];\nconst assembleG = (tpl, syms, ret = \"a\", pre, post, strided = false) => [\n    pre,\n    \"for(let i=a.length;--i>=0;) {\",\n    tpl(syms\n        .split(\",\")\n        .map(strided ? (x) => `${x}[i${x}+i*s${x}]` : (x) => `${x}[i]`)),\n    \"}\",\n    post,\n    ret !== null ? `return ${ret};` : \"\",\n];\n/** @internal */\nconst defaultOut = (o, args) => `!${o} && (${o}=${args.split(\",\")[1]});`;\n/** @internal */\nconst compile = (dim, tpl, args, syms = args, ret = \"a\", opJoin, pre, post, strided = false) => (new Function(args, assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join(\"\")));\n/** @internal */\nconst compileHOF = (dim, fns, tpl, hofArgs, args, syms = args, ret = \"a\", opJoin = \"\", pre, post, strided = false) => {\n    return new Function(hofArgs, `return (${args})=>{${assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join(\"\")}}`)(...fns);\n};\n/** @internal */\nconst compileG = (tpl, args, syms = args, ret = \"a\", pre, post, strided = false) => (new Function(args, assembleG(tpl, syms, ret, pre, post, strided).join(\"\")));\n/** @internal */\nconst compileGHOF = (fns, tpl, hofArgs, args, syms = args, ret = \"a\", pre, post, strided = false) => (new Function(hofArgs, `return (${args})=>{${assembleG(tpl, syms, ret, pre, post, strided).join(\"\")}}`)(...fns));\nconst defOp = (tpl, args = ARGS_VV, syms, ret = \"o\", dispatch = 1, pre) => {\n    syms = syms || args;\n    pre = pre != null ? pre : defaultOut(ret, args);\n    const fn = vop(dispatch);\n    const $ = (dim) => fn.add(dim, compile(dim, tpl, args, syms, ret, \"\", pre));\n    fn.default(compileG(tpl, args, syms, ret, pre));\n    return [fn, $(2), $(3), $(4)];\n};\nconst defFnOp = (op) => defOp(FN(op), ARGS_V);\nconst defHofOp = (op, tpl, args = ARGS_V, syms, ret = \"o\", dispatch = 1, pre) => {\n    const _tpl = tpl || FN(\"op\");\n    syms = syms || args;\n    pre = pre != null ? pre : defaultOut(ret, args);\n    const $ = (dim) => compileHOF(dim, [op], _tpl, \"op\", args, syms, ret, \"\", pre);\n    const fn = vop(dispatch);\n    fn.default(compileGHOF([op], _tpl, \"op\", args, syms, ret, pre));\n    return [fn, $(2), $(3), $(4)];\n};\nconst defMathOp = (op) => defOp(MATH(op));\nconst defMathOpN = (op) => defOp(MATH_N(op), ARGS_VN);\n\nexport { $iter as $, ARGS_VV as A, defHofOp as B, ARGS_VN as C, DEG2RAD as D, EPS as E, FN2 as F, FN_N as G, HALF_PI as H, SQRT2_2 as I, THIRD_PI as J, unsupported as K, transduce as L, MATH2A_N as M, NO_OP as N, zip as O, PI as P, push as Q, SQRT3 as R, SARGS_V as S, TAU as T, isArrayLike as U, compileG as V, NEW_OUT as W, SET as X, compileHOF as Y, DOT_G as Z, MIX_N as _, reducer as a, SET_N as a0, isIterable as b, compR as c, defError as d, ensureReduced as e, iterator1 as f, iterator as g, comp$1 as h, isReduced as i, mapIndexed as j, defFnOp as k, defOp as l, map as m, ARGS_VNV as n, ARGS_VVN as o, MATH2_N as p, defMathOpN as q, reduce as r, implementsFunction as s, defMathOp as t, unreduced as u, vop as v, compile as w, DOT as x, ARGS_VVV as y, MATH2 as z };\n", "import { d as defError, v as vop, V as compileG, w as compile } from './codegen-df7bb22c.js';\n\nconst IllegalArgumentError = defError(() => \"illegal argument(s)\");\nconst illegalArgs = (msg) => {\n    throw new IllegalArgumentError(msg);\n};\n\nconst tpl = ([a, b]) => `t=${a}-${b};s+=t*t;`;\nconst pre = \"let t,s=0;\";\nconst $ = (dim) => distSq.add(dim, compile(dim, tpl, \"a,b\", undefined, \"s\", \"\", pre));\nconst distSq = vop();\ndistSq.default(compileG(tpl, \"a,b\", undefined, \"s\", pre));\nconst distSq2 = $(2);\nconst distSq3 = $(3);\nconst distSq4 = $(4);\n\nexport { distSq2 as a, distSq as d, illegalArgs as i };\n", "import { v as vop, V as compileG, w as compile, l as defOp, W as NEW_OUT, X as SET } from './codegen-df7bb22c.js';\n\nconst $ = (dim) => magSq.add(dim, compile(dim, ([a]) => `${a}*${a}`, \"a\", \"a\", \"\", \"+\", \"return \", \";\"));\nconst magSq = vop();\nmagSq.default(compileG(([a]) => `sum+=${a}*${a};`, \"a\", undefined, \"sum\", \"let sum=0;\"));\nconst magSq2 = $(2);\nconst magSq3 = $(3);\nconst magSq4 = $(4);\n\nconst [set, set2, set3, set4] = defOp(SET, \"o,a\", undefined, \"o\", 1, NEW_OUT);\n\nexport { set2 as a, set3 as b, magSq as c, magSq2 as m, set as s };\n", "import { t as defMathOp } from './codegen-df7bb22c.js';\n\nconst isNumber = (x) => typeof x === \"number\";\n\nconst [add, add2, add3, add4] = defMathOp(\"+\");\n\nexport { add3 as a, add2 as b, add as c, isNumber as i };\n", "import { E as EPS, v as vop, s as implementsFunction, Y as compileHOF, V as compileG, w as compile, x as DOT, Z as DOT_G, t as defMathOp, l as defOp, o as ARGS_VVN, _ as MIX_N, q as defMathOpN, a0 as SET_N } from './codegen-df7bb22c.js';\nimport { d as distSq, i as illegalArgs } from './distsq-d74f45eb.js';\nimport { c as magSq, s as set } from './set-c051c4f9.js';\nimport { c as add } from './add-5cc35f4d.js';\n\nconst mi = -Infinity;\nconst mx = Infinity;\nconst MIN2 = Object.freeze([mi, mi]);\nconst MAX2 = Object.freeze([mx, mx]);\nconst ONE2 = Object.freeze([1, 1]);\nconst ZERO2 = Object.freeze([0, 0]);\nconst X2 = Object.freeze([1, 0]);\nconst Y2 = Object.freeze([0, 1]);\nconst MIN3 = Object.freeze([mi, mi, mi]);\nconst MAX3 = Object.freeze([mx, mx, mx]);\nconst ONE3 = Object.freeze([1, 1, 1]);\nconst ZERO3 = Object.freeze([0, 0, 0]);\nconst X3 = Object.freeze([1, 0, 0]);\nconst Y3 = Object.freeze([0, 1, 0]);\nconst Z3 = Object.freeze([0, 0, 1]);\nconst MIN4 = Object.freeze([mi, mi, mi, mi]);\nconst MAX4 = Object.freeze([mx, mx, mx, mx]);\nconst ONE4 = Object.freeze([1, 1, 1, 1]);\nconst ZERO4 = Object.freeze([0, 0, 0, 0]);\nconst X4 = Object.freeze([1, 0, 0, 0]);\nconst Y4 = Object.freeze([0, 1, 0, 0]);\nconst Z4 = Object.freeze([0, 0, 1, 0]);\nconst W4 = Object.freeze([0, 0, 0, 1]);\n\nconst sign = (x, eps = EPS) => (x > eps ? 1 : x < -eps ? -1 : 0);\n\nconst abs = Math.abs;\n/**\n * Similar to {@link eqDeltaScaled}, but uses given `eps` as is.\n *\n * @param a - left value\n * @param b - right value\n * @param eps - epsilon / tolerance, default `1e-6`\n */\nconst eqDelta = (a, b, eps = EPS) => abs(a - b) <= eps;\n\n/**\n * Clamps value `x` to given closed interval.\n *\n * @param x - value to clamp\n * @param min - lower bound\n * @param max - upper bound\n */\nconst clamp = (x, min, max) => (x < min ? min : x > max ? max : x);\n/**\n * Clamps value `x` to closed [0 .. 1] interval.\n *\n * @param x\n */\nconst clamp01 = (x) => (x < 0 ? 0 : x > 1 ? 1 : x);\n/**\n * Returns the non-zero minimum value of the given `a`, `b` args.\n *\n * @param a\n * @param b\n */\nconst minNonZero2 = (a, b) => a !== 0 ? (b !== 0 ? Math.min(a, b) : a) : b;\n/**\n * Returns the non-zero minimum value of the given `a`, `b`, `c` args.\n *\n * @param a\n * @param b\n * @param c\n */\nconst minNonZero3 = (a, b, c) => minNonZero2(minNonZero2(a, b), c);\n/**\n * Returns true iff `x` is in closed interval `[min .. max]`\n *\n * @param x -\n * @param min -\n * @param max -\n */\nconst inRange = (x, min, max) => x >= min && x <= max;\n\nconst $ = (dim) => eqDelta$1.add(dim, compileHOF(dim, [eqDelta, EPS], ([a, b]) => `eq(${a},${b},eps)`, \"eq,_eps\", \"a,b,eps=_eps\", \"a,b\", \"\", \"&&\", \"return a.length === b.length && \", \";\"));\n/**\n * Checks given vectors for componentwise equality, taking tolerance\n * `eps` (default: {@link @thi.ng/math#EPS}) into account.\n *\n * @param a\n * @param b\n * @param eps\n */\nconst eqDelta$1 = vop();\neqDelta$1.default((v1, v2, eps = EPS) => {\n    if (implementsFunction(v1, \"eqDelta\")) {\n        return v1.eqDelta(v2, eps);\n    }\n    if (implementsFunction(v2, \"eqDelta\")) {\n        return v2.eqDelta(v1, eps);\n    }\n    return eqDeltaS(v1, v2, v1.length, eps);\n});\nconst eqDelta2 = $(2);\nconst eqDelta3 = $(3);\nconst eqDelta4 = $(4);\n/**\n * Checks given strided vectors for componentwise equality, taking\n * tolerance `eps` (default: {@link @thi.ng/math#EPS}) into account.\n *\n * @param a - first vector\n * @param b - second vector\n * @param n - number of elements\n * @param eps - tolerance\n * @param ia - start index a\n * @param ib - start index b\n * @param sa - stride a\n * @param sb - stride b\n */\nconst eqDeltaS = (a, b, n, eps = EPS, ia = 0, ib = 0, sa = 1, sb = 1) => {\n    for (; n > 0; n--, ia += sa, ib += sb) {\n        if (!eqDelta(a[ia], b[ib], eps)) {\n            return false;\n        }\n    }\n    return true;\n};\nconst isInArray = (p, pts, eps = EPS) => {\n    for (let i = pts.length; --i >= 0;) {\n        if (eqDelta$1(p, pts[i], eps)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nconst $$1 = (dim) => dot.add(dim, compile(dim, DOT, \"a,b\", undefined, \"\", \"+\", \"return \", \";\"));\nconst dot = vop();\ndot.default(compileG(DOT_G, \"a,b\", undefined, \"s\", \"let s=0;\"));\nconst dot2 = $$1(2);\nconst dot3 = $$1(3);\nconst dot4 = $$1(4);\n\nconst [sub, sub2, sub3, sub4] = defMathOp(\"-\");\n\nconst [mixN, mixN2, mixN3, mixN4] = defOp(MIX_N, ARGS_VVN);\n\n/**\n * Returns 2x the signed area of the 2D triangle defined by the given points.\n *\n * @remarks\n * This is a useful classifier for many geometry processing tasks. In addition\n * to the triangle area, the result can also be interpreted as follows:\n *\n * - `> 0`: points are ordered counterclockwise\n * - `< 0`: points are ordered clockwise\n * - `0`: points are co-linear\n *\n * Functionally same as: `cross2(sub2([], b, a), sub2([], c, a))`\n *\n * - {@link corner2}\n * - {@link clockwise2}\n * - {@link cross2}\n *\n * @param a -\n * @param b -\n * @param c -\n */\nconst signedArea2 = (a, b, c) => {\n    const ax = a[0];\n    const ay = a[1];\n    return (b[0] - ax) * (c[1] - ay) - (c[0] - ax) * (b[1] - ay);\n};\n\n/**\n * Syntax sugar for `sign(signedArea2(a, b, c))`.\n *\n * - {@link @thi.ng/math#sign}\n * - {@link signedArea2}\n *\n * @param a -\n * @param b -\n * @param c -\n * @param eps - zero tolerance for sign computation\n */\nconst corner2 = (a, b, c, eps = EPS) => sign(signedArea2(a, b, c), eps);\n/**\n * Returns true, if the triangle `a`, `b`, `c` is in clockwise order,\n * i.e. if `corner2(a,b,c)` returned -1.\n *\n * @param a -\n * @param b -\n * @param c -\n * @param eps -\n */\nconst clockwise2 = (a, b, c, eps = EPS) => corner2(a, b, c, eps) < 0;\n\nconst [divN, divN2, divN3, divN4] = defMathOpN(\"/\");\n\nconst [setN, setN2, setN3, setN4] = defOp(SET_N, \"a,n\", \"a\", \"a\", 0, \"\");\nconst zeroes = (n) => new Array(n).fill(0);\n\nconst empty = (v) => implementsFunction(v, \"empty\") ? v.empty() : zeroes(v.length);\n\nvar IntersectionType;\n(function (IntersectionType) {\n    IntersectionType[IntersectionType[\"NONE\"] = 0] = \"NONE\";\n    IntersectionType[IntersectionType[\"PARALLEL\"] = 1] = \"PARALLEL\";\n    IntersectionType[IntersectionType[\"COINCIDENT\"] = 2] = \"COINCIDENT\";\n    IntersectionType[IntersectionType[\"COINCIDENT_NO_INTERSECT\"] = 3] = \"COINCIDENT_NO_INTERSECT\";\n    IntersectionType[IntersectionType[\"INTERSECT\"] = 4] = \"INTERSECT\";\n    IntersectionType[IntersectionType[\"INTERSECT_OUTSIDE\"] = 5] = \"INTERSECT_OUTSIDE\";\n})(IntersectionType || (IntersectionType = {}));\n\n/**\n * Computes the parametric distance `t` of point `p` projected onto line\n * `a` -> `b`, relative to `a`. I.e. the projection of `p` can then be\n * computed like so:\n *\n * @example\n * ```ts\n * mixN([], a, b, closestT(p, a, b))\n * ```\n *\n * If the return value is outside the closed [0,1] interval, the\n * projected point lies outside the line segment. Returns `undefined` if\n * `a` and `b` are coincident.\n *\n * - {@link closestPointLine}\n * - {@link closestPointSegment}\n *\n * @param p - query point\n * @param a - line point A\n * @param b - line point B\n */\nconst closestT = (p, a, b) => {\n    const d = sub([], b, a);\n    const l = magSq(d);\n    return l > 1e-6 ? dot(sub([], p, a), d) / l : undefined;\n};\n/**\n * Returns closest point to `p` on line segment `a` -> `b`. By default,\n * if the result point lies outside the segment, returns a copy of the\n * closest end point. The result is written to the optional `out` vector\n * (or if omitted, a new one is created).\n *\n * If `insideOnly` is true, only returns the closest point iff it\n * actually is inside the segment. The behavior of this configurable via\n * the optional `eps` arg and by default includes both end points. This\n * function uses {@link closestT} to compute the parametric position of the\n * result point and determine if it lies within the line segment. If\n * `eps > 0`, the end points `a` and `b` will be excluded from the\n * match, effectively shortening the valid line segment from both ends,\n * i.e. the valid interval of the parametric position will be\n * [eps,1-eps]. If the result lies outside this interval, the function\n * returns `undefined`. Likewise, if `a` and `b` are coincident.\n *\n * @param p - query point\n * @param a - line point A\n * @param b - line point B\n * @param out - result\n * @param eps - epsilon value\n */\nconst closestPointSegment = (p, a, b, out, insideOnly = false, eps = 0) => {\n    const t = closestT(p, a, b);\n    if (t !== undefined && (!insideOnly || (t >= eps && t <= 1 - eps))) {\n        out = out || empty(p);\n        return t <= 0 ? set(out, a) : t >= 1 ? set(out, b) : mixN(out, a, b, t);\n    }\n};\nconst closestPointPolyline = (p, pts, closed = false, out = []) => {\n    if (!pts.length)\n        return;\n    const tmp = [];\n    const n = pts.length - 1;\n    let minD = Infinity, i, j;\n    if (closed) {\n        i = n;\n        j = 0;\n    }\n    else {\n        i = 0;\n        j = 1;\n    }\n    for (; j <= n; i = j, j++) {\n        if (closestPointSegment(p, pts[i], pts[j], tmp)) {\n            const d = distSq(p, tmp);\n            if (d < minD) {\n                minD = d;\n                set(out, tmp);\n            }\n        }\n    }\n    return minD < Infinity ? out : undefined;\n};\n/**\n * Returns the index of the start point containing the segment in the\n * polyline array `points` farthest away from `p` with regards to the\n * line segment `a` to `b`. `points` is only checked between indices\n * `from` and `to` (not including the latter).\n *\n * @param a - line point A\n * @param b - line point B\n * @param points - points\n * @param from - start search index\n * @param to - end search index\n */\nconst farthestPointSegment = (a, b, points, from = 0, to = points.length) => {\n    let maxD = -1;\n    let maxIdx = -1;\n    const tmp = empty(a);\n    for (let i = from; i < to; i++) {\n        const p = points[i];\n        const d = distSq(p, closestPointSegment(p, a, b, tmp) || a);\n        if (d > maxD) {\n            maxD = d;\n            maxIdx = i;\n        }\n    }\n    return [maxIdx, Math.sqrt(maxD)];\n};\n\nconst centroid = (pts, out) => {\n    const num = pts.length;\n    !num && illegalArgs(\"no points\");\n    !out && (out = empty(pts[0]));\n    for (let i = num; --i >= 0;) {\n        add(out, out, pts[i]);\n    }\n    return divN(out, out, num);\n};\n\n/**\n * Computes and returns the center of the circumcircle of the given 2D\n * triangle points. Returns `undefined` if the points are colinear or\n * coincident.\n *\n * @param a - triangle vertex 1\n * @param b - triangle vertex 2\n * @param c - triangle vertex 3\n * @param eps - epsilon value for colinear check\n */\nconst circumCenter2 = (a, b, c, eps = EPS) => {\n    const ax = a[0], ay = a[1];\n    const bx = b[0], by = b[1];\n    const cx = c[0], cy = c[1];\n    const bax = bx - ax;\n    const bay = by - ay;\n    const cbx = cx - bx;\n    const cby = cy - by;\n    const deltaAB = Math.abs(bay);\n    const deltaBC = Math.abs(cby);\n    // colinear check\n    if ((deltaAB < eps && deltaBC < eps) ||\n        (Math.abs(bax) < eps && Math.abs(cbx) < eps)) {\n        return;\n    }\n    const abx2 = (ax + bx) / 2;\n    const aby2 = (ay + by) / 2;\n    const bcx2 = (bx + cx) / 2;\n    const bcy2 = (by + cy) / 2;\n    if (deltaAB < eps) {\n        return [abx2, (-cbx / cby) * (abx2 - bcx2) + bcy2];\n    }\n    if (deltaBC < eps) {\n        return [bcx2, (-bax / bay) * (bcx2 - abx2) + aby2];\n    }\n    let m1 = -bax / bay;\n    let m2 = -cbx / cby;\n    let mx1 = abx2;\n    let my1 = aby2;\n    let mx2 = bcx2;\n    let my2 = bcy2;\n    let xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);\n    let yc = deltaAB > deltaBC ? m1 * (xc - mx1) + my1 : m2 * (xc - mx2) + my2;\n    return [xc, yc];\n};\n\nconst pointInSegment = (p, a, b, eps = EPS) => {\n    const t = closestT(p, a, b);\n    return t !== undefined\n        ? distSq(p, mixN([], a, b, clamp01(t))) < eps * eps\n        : false;\n};\nconst pointInCircle = (p, pos, r) => distSq(pos, p) <= r * r;\nconst classifyPointInCircle = (p, pos, r, eps = EPS) => sign(r * r - distSq(pos, p), eps);\nconst pointInCircumCircle = (a, b, c, d) => magSq(a) * signedArea2(b, c, d) -\n    magSq(b) * signedArea2(a, c, d) +\n    magSq(c) * signedArea2(a, b, d) -\n    magSq(d) * signedArea2(a, b, c) >\n    0;\nconst pointInTriangle2 = (p, a, b, c) => {\n    const s = clockwise2(a, b, c) ? 1 : -1;\n    return (s * signedArea2(a, c, p) >= 0 &&\n        s * signedArea2(b, a, p) >= 0 &&\n        s * signedArea2(c, b, p) >= 0);\n};\nconst classifyPointInTriangle2 = (p, a, b, c, eps = EPS) => {\n    const s = clockwise2(a, b, c) ? 1 : -1;\n    return sign(Math.min(s * signedArea2(a, c, p), s * signedArea2(b, a, p), s * signedArea2(c, b, p)), eps);\n};\nconst pointInPolygon2 = (p, pts) => {\n    const n = pts.length - 1;\n    const px = p[0];\n    const py = p[1];\n    let a = pts[n];\n    let b = pts[0];\n    let inside = 0;\n    for (let i = 0; i <= n; a = b, b = pts[++i]) {\n        inside = classifyPointPolyPair(px, py, a[0], a[1], b[0], b[1], inside);\n    }\n    return inside;\n};\nconst classifyPointPolyPair = (px, py, ax, ay, bx, by, inside) => ((ay < py && by >= py) || (by < py && ay >= py)) && (ax <= px || bx <= px)\n    ? inside ^ (ax + ((py - ay) / (by - ay)) * (bx - ax) < px ? 1 : 0)\n    : inside;\nconst pointInBox = vop(0);\nconst pointInRect = pointInBox.add(2, ([x, y], pos, size) => x >= pos[0] &&\n    x <= pos[0] + size[0] &&\n    y >= pos[1] &&\n    y <= pos[1] + size[1]);\nconst pointInAABB = pointInBox.add(3, ([x, y, z], pos, size) => x >= pos[0] &&\n    x <= pos[0] + size[0] &&\n    y >= pos[1] &&\n    y <= pos[1] + size[1] &&\n    z >= pos[2] &&\n    z <= pos[2] + size[2]);\npointInBox.default((p, boxMin, boxSize) => {\n    for (let i = p.length; --i >= 0;) {\n        const x = p[i];\n        const y = boxMin[i];\n        if (x < y || x > y + boxSize[i])\n            return false;\n    }\n    return true;\n});\nconst pointInCenteredBox = vop(0);\nconst pointInCenteredRect = pointInCenteredBox.add(2, ([x, y], pos, size) => x >= pos[0] - size[0] &&\n    x <= pos[0] + size[0] &&\n    y >= pos[1] - size[1] &&\n    y <= pos[1] + size[1]);\nconst pointInCenteredAABB = pointInCenteredBox.add(3, ([x, y, z], pos, size) => x >= pos[0] - size[0] &&\n    x <= pos[0] + size[0] &&\n    y >= pos[1] - size[1] &&\n    y <= pos[1] + size[1] &&\n    z >= pos[2] - size[2] &&\n    z <= pos[2] + size[2]);\npointInCenteredBox.default((p, boxCenter, boxExtent) => {\n    for (let i = p.length; --i >= 0;) {\n        const x = p[i];\n        const y = boxCenter[i];\n        const z = boxExtent[i];\n        if (x < y - z || x > y + z)\n            return false;\n    }\n    return true;\n});\n\nconst intersectLineLine = (a, b, c, d, eps = EPS) => {\n    const bax = b[0] - a[0];\n    const bay = b[1] - a[1];\n    const dcx = d[0] - c[0];\n    const dcy = d[1] - c[1];\n    const acx = a[0] - c[0];\n    const acy = a[1] - c[1];\n    const det = dcy * bax - dcx * bay;\n    let alpha = dcx * acy - dcy * acx;\n    let beta = bax * acy - bay * acx;\n    if (eqDelta(det, 0, eps)) {\n        if (eqDelta(alpha, 0, eps) && eqDelta(beta, 0, eps)) {\n            let isec = closestPointSegment(c, a, b, undefined, true) ||\n                closestPointSegment(d, a, b, undefined, true);\n            return {\n                type: isec\n                    ? IntersectionType.COINCIDENT\n                    : IntersectionType.COINCIDENT_NO_INTERSECT,\n                isec,\n            };\n        }\n        return { type: IntersectionType.PARALLEL };\n    }\n    alpha /= det;\n    beta /= det;\n    const ieps = 1 - eps;\n    return {\n        type: eps < alpha && alpha < ieps && eps < beta && beta < ieps\n            ? IntersectionType.INTERSECT\n            : IntersectionType.INTERSECT_OUTSIDE,\n        isec: mixN2([], a, b, alpha),\n        alpha,\n        beta,\n        det,\n    };\n};\n\n/**\n * Performs Liang-Barsky clipping of the line segment with endpoints\n * `a`, `b` against the clipping rect defined by `min` and `max`. The\n * optional `ca` and `cb` vectors can be given to store the result\n * (clipped points). If omitted creates new vectors. Returns a tuple of\n * `[ca, cb, a, b]`, where the latter two values represent the\n * normalized distances of the clipped points relative to original given\n * line segment. Returns `undefined` iff the line lies completely\n * outside the rect.\n *\n * - {@link https://en.wikipedia.org/wiki/Liang%E2%80%93Barsky_algorithm}\n * - {@link https://github.com/thi-ng/c-thing/blob/develop/src/geom/clip/liangbarsky.c}\n *\n * @param a - line endpoint\n * @param b - line endpoint\n * @param min - bbox min\n * @param max - bbox max\n * @param ca - result A\n * @param cb - result B\n */\nconst liangBarsky2 = (a, b, min, max, ca = [], cb = []) => {\n    const res = liangBarsky2Raw(a[0], a[1], b[0], b[1], min[0], min[1], max[0], max[1]);\n    if (!res)\n        return;\n    ca[0] = res[0];\n    ca[1] = res[1];\n    cb[0] = res[2];\n    cb[1] = res[3];\n    return [ca, cb, res[4], res[5]];\n};\n/**\n * Same as {@link liangBarsky2} but for non-vector arguments.\n *\n * @param ax\n * @param ay\n * @param bx\n * @param by\n * @param minx\n * @param miny\n * @param maxx\n * @param maxy\n */\nconst liangBarsky2Raw = (ax, ay, bx, by, minx, miny, maxx, maxy) => {\n    const dx = bx - ax;\n    const dy = by - ay;\n    let alpha = 0;\n    let beta = 1;\n    const clip = (p, q) => {\n        if (p < 0) {\n            const r = q / p;\n            if (r > beta) {\n                return false;\n            }\n            if (r > alpha) {\n                alpha = r;\n            }\n        }\n        else if (p > 0) {\n            const r = q / p;\n            if (r < alpha) {\n                return false;\n            }\n            if (r < beta) {\n                beta = r;\n            }\n        }\n        else if (q < 0) {\n            return false;\n        }\n        return true;\n    };\n    return clip(-dx, ax - minx) &&\n        clip(dx, maxx - ax) &&\n        clip(-dy, ay - miny) &&\n        clip(dy, maxy - ay)\n        ? [\n            alpha * dx + ax,\n            alpha * dy + ay,\n            beta * dx + ax,\n            beta * dy + ay,\n            alpha,\n            beta,\n        ]\n        : undefined;\n};\n\n/**\n * Extended version of Sutherland-Hodgeman convex polygon clipping\n * supporting any convex boundary polygon (not only rects). Returns new\n * array of clipped vertices.\n *\n * {@link https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm}\n *\n * @param pts - subject poly vertices\n * @param bounds - clipping boundary vertices\n * @param bc - pre-computed boundary centroid\n * @param eps - edge classification tolerance\n */\nconst sutherlandHodgeman = (pts, bounds, bc, eps = EPS) => {\n    bc = bc || centroid(bounds);\n    for (let ne = bounds.length, j = ne - 1, i = 0; i < ne; j = i, i++) {\n        const clipped = [];\n        const ca = bounds[j];\n        const cb = bounds[i];\n        const sign = corner2(ca, cb, bc, eps);\n        for (let np = pts.length, k = np - 1, l = 0; l < np; k = l, l++) {\n            const p = pts[k];\n            const q = pts[l];\n            const cqsign = corner2(ca, cb, q, eps);\n            if (corner2(ca, cb, p, eps) === sign) {\n                clipped.push(cqsign !== sign\n                    ? intersectLineLine(ca, cb, p, q).isec\n                    : q);\n            }\n            else if (cqsign === sign) {\n                clipped.push(intersectLineLine(ca, cb, p, q).isec, q);\n            }\n        }\n        if (clipped.length < 2) {\n            return [];\n        }\n        pts = clipped;\n    }\n    return pts;\n};\n\nexport { centroid as A, signedArea2 as B, MIN3 as C, MAX3 as D, divN as E, classifyPointInCircle as F, classifyPointInTriangle2 as G, sutherlandHodgeman as H, IntersectionType as I, minNonZero2 as J, minNonZero3 as K, intersectLineLine as L, MAX2 as M, pointInAABB as N, pointInCircle as O, pointInSegment as P, isInArray as Q, pointInRect as R, pointInTriangle2 as S, pointInCircumCircle as T, X2 as X, ZERO2 as Z, ZERO3 as a, sub3 as b, clamp01 as c, dot as d, MIN2 as e, eqDelta2 as f, sub2 as g, clamp as h, inRange as i, closestPointPolyline as j, closestPointSegment as k, closestT as l, mixN as m, eqDelta$1 as n, farthestPointSegment as o, mixN2 as p, circumCenter2 as q, corner2 as r, sub as s, eqDelta as t, dot3 as u, sign as v, pointInPolygon2 as w, liangBarsky2 as x, Z3 as y, zeroes as z };\n", "import { P as pointInSegment, B as signedArea2, T as pointInCircumCircle, f as eqDelta2, q as circumCenter2, Z as ZERO2, A as centroid, w as pointInPolygon2, H as sutherlandHodgeman, x as liangBarsky2 } from '../common/index-e6512bd8.js';\nimport { i as isNumber } from '../common/add-5cc35f4d.js';\nimport { E as EPS } from '../common/codegen-df7bb22c.js';\nimport '../common/distsq-d74f45eb.js';\nimport '../common/set-c051c4f9.js';\n\nlet NEXT_ID = 0;\n/**\n * Quad-edge implementation after Guibas & Stolfi. Based on C++ versions\n * by Paul Heckbert, Dani Lischinski et al:\n *\n * References:\n *\n * - {@link http://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html}\n * - {@link http://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/lischinski/114.ps}\n */\nclass Edge {\n    constructor(parent, id) {\n        this.parent = parent;\n        this.id = id;\n    }\n    /**\n     * Main edge / quadedge factory function. Use this in preference of\n     * direct invocation of the {@link Edge} constructor.\n     *\n     * Creates new {@link QuadEdge} with 4 child edges and returns the first\n     * child/primary edge. If `src` and `dest` are not `null`ish, the\n     * given args will be associated with that new edge as end points.\n     *\n     * @param src -\n     * @param dest -\n     */\n    static create(src, dest) {\n        const quad = new Array(4);\n        const a = (quad[0] = new Edge(quad, NEXT_ID));\n        const b = (quad[1] = new Edge(quad, NEXT_ID + 1));\n        const c = (quad[2] = new Edge(quad, NEXT_ID + 2));\n        const d = (quad[3] = new Edge(quad, NEXT_ID + 3));\n        a.onext = a;\n        c.onext = c;\n        b.onext = d;\n        d.onext = b;\n        NEXT_ID += 4;\n        src && dest && a.setEnds(src, dest);\n        return a;\n    }\n    /**\n     * Next CW edge from this edge's origin.\n     */\n    get oprev() {\n        return this.rot.onext.rot;\n    }\n    /**\n     * Dual of this edge, right -> left.\n     */\n    get rot() {\n        return this.parent[(this.id + 1) & 3];\n    }\n    /**\n     * Dual of this edge, left -> right.\n     * I.e same as `this.rot.sym`\n     */\n    get invrot() {\n        return this.parent[(this.id + 3) & 3];\n    }\n    /**\n     * Symmetric partner edge of this edge, from dest -> src.\n     * I.e. `this === this.sym.sym`\n     */\n    get sym() {\n        return this.parent[(this.id + 2) & 3];\n    }\n    /**\n     * Next CCW edge to this edge's dest.\n     */\n    get dnext() {\n        return this.sym.onext.sym;\n    }\n    /**\n     * Next CW edge to this edge's dest.\n     */\n    get dprev() {\n        return this.invrot.onext.invrot;\n    }\n    /**\n     * Next CCW edge around the left face (dual vertex) from this edge's\n     * dest.\n     */\n    get lnext() {\n        return this.invrot.onext.rot;\n    }\n    /**\n     * Next CCW edge around the left face (dual vertex) to this edge's\n     * origin.\n     */\n    get lprev() {\n        return this.onext.sym;\n    }\n    /**\n     * Next CCW edge around the right face (dual vertex) to this edge's\n     * dest.\n     */\n    get rnext() {\n        return this.rot.onext.invrot;\n    }\n    /**\n     * Next CCW edge around the right face (dual vertex) to this edge's\n     * origin.\n     */\n    get rprev() {\n        return this.sym.onext;\n    }\n    /**\n     * Returns this edge's dest vertex. I.e. `this.sym.origin`\n     */\n    get dest() {\n        return this.sym.origin;\n    }\n    /**\n     * Sets the origin & dest vertices of this edge (in other words, the\n     * origins of this edge and `this.sym`).\n     *\n     * @param o -\n     * @param d -\n     */\n    setEnds(o, d) {\n        this.origin = o;\n        this.sym.origin = d;\n    }\n    connect(e) {\n        const n = Edge.create();\n        n.splice(this.lnext);\n        n.sym.splice(e);\n        n.setEnds(this.dest, e.origin);\n        return n;\n    }\n    swap() {\n        const a = this.oprev;\n        const b = this.sym.oprev;\n        this.splice(a);\n        this.sym.splice(b);\n        this.splice(a.lnext);\n        this.sym.splice(b.lnext);\n        this.setEnds(a.dest, b.dest);\n    }\n    remove() {\n        this.splice(this.oprev);\n        this.sym.splice(this.sym.oprev);\n        delete this.parent;\n    }\n    /**\n     * Modifies the edge rings around the origins of this edge and `e`,\n     * as well as, independently, the edge rings of both edges' left\n     * dual vertex. In each case, if the rings are separate, this\n     * operator will join them and if both rings are the same ring, they\n     * will be split / separated. Therefore, splice` is it's own reverse\n     * operator and the only operator needed to edit quad edge\n     * topologies.\n     *\n     * @param e -\n     */\n    splice(e) {\n        const alpha = this.onext.rot;\n        const beta = e.onext.rot;\n        const t1 = e.onext;\n        const t2 = this.onext;\n        const t3 = beta.onext;\n        const t4 = alpha.onext;\n        this.onext = t1;\n        e.onext = t2;\n        alpha.onext = t3;\n        beta.onext = t4;\n        return this;\n    }\n}\n\nconst rightOf = (p, e) => signedArea2(p, e.dest.pos, e.origin.pos) > 0;\nclass DVMesh {\n    constructor(pts, size = 1e5) {\n        const a = { pos: [0, -size], id: 0 };\n        const b = { pos: [size, size], id: 1 };\n        const c = { pos: [-size, size], id: 2 };\n        const eab = Edge.create(a, b);\n        const ebc = Edge.create(b, c);\n        const eca = Edge.create(c, a);\n        eab.sym.splice(ebc);\n        ebc.sym.splice(eca);\n        eca.sym.splice(eab);\n        this.first = eab;\n        this.nextID = 3;\n        if (pts && pts.length) {\n            isNumber(pts[0][0])\n                ? this.addKeys(pts)\n                : this.addAll(pts);\n        }\n        else {\n            this.computeDual();\n        }\n    }\n    /**\n     * Adds a single new point `p` w/ optional value `val` to the mesh, unless\n     * there already is another point existing within radius `eps`. If `update`\n     * is true (default), the mesh dual will be automatically updated using\n     * {@link DVMesh.computeDual}.\n     *\n     * @remarks\n     * If adding multiple points, ensure `computeDual` will only be called\n     * for/after the last point insertion to avoid computational overhead.\n     *\n     * @param p\n     * @param val\n     * @param eps\n     * @param update\n     */\n    add(p, val, eps = EPS, update = true) {\n        let [e, exists] = this.locate(p, eps);\n        if (exists)\n            return false;\n        if (pointInSegment(p, e.origin.pos, e.dest.pos)) {\n            e = e.oprev;\n            e.onext.remove();\n        }\n        let base = Edge.create(e.origin, {\n            pos: p,\n            id: this.nextID++,\n            val,\n        });\n        base.splice(e);\n        const first = base;\n        do {\n            base = e.connect(base.sym);\n            e = base.oprev;\n        } while (e.lnext !== first);\n        // enforce delaunay constraints\n        do {\n            const t = e.oprev;\n            if (rightOf(t.dest.pos, e) &&\n                pointInCircumCircle(e.origin.pos, t.dest.pos, e.dest.pos, p)) {\n                e.swap();\n                e = e.oprev;\n            }\n            else if (e.onext !== first) {\n                e = e.onext.lprev;\n            }\n            else {\n                break;\n            }\n        } while (true);\n        update && this.computeDual();\n        return true;\n    }\n    addKeys(pts, eps) {\n        for (let p of pts) {\n            this.add(p, undefined, eps, false);\n        }\n        this.computeDual();\n    }\n    addAll(pairs, eps) {\n        for (let p of pairs) {\n            this.add(p[0], p[1], eps, false);\n        }\n        this.computeDual();\n    }\n    /**\n     * Returns tuple of the edge related to `p` and a boolean to indicate if\n     * `p` already exists in this triangulation (true if already present).\n     *\n     * @param p - query point\n     */\n    locate(p, eps = EPS) {\n        let e = this.first;\n        while (true) {\n            if (eqDelta2(p, e.origin.pos, eps) ||\n                eqDelta2(p, e.dest.pos, eps)) {\n                return [e, true];\n            }\n            else if (rightOf(p, e)) {\n                e = e.sym;\n            }\n            else if (!rightOf(p, e.onext)) {\n                e = e.onext;\n            }\n            else if (!rightOf(p, e.dprev)) {\n                e = e.dprev;\n            }\n            else {\n                return [e, false];\n            }\n        }\n    }\n    /**\n     * Syncronize / update / add dual faces (i.e. Voronoi) for current\n     * primary mesh (i.e. Delaunay).\n     */\n    computeDual() {\n        const work = [this.first.rot];\n        const visitedEdges = {};\n        const visitedVerts = {};\n        while (work.length) {\n            const e = work.pop();\n            if (visitedEdges[e.id])\n                continue;\n            visitedEdges[e.id] = true;\n            if (!e.origin || !visitedVerts[e.origin.id]) {\n                let t = e.rot;\n                const a = t.origin.pos;\n                let isBoundary = t.origin.id < 3;\n                t = t.lnext;\n                const b = t.origin.pos;\n                isBoundary = isBoundary && t.origin.id < 3;\n                t = t.lnext;\n                const c = t.origin.pos;\n                isBoundary = isBoundary && t.origin.id < 3;\n                const id = this.nextID++;\n                e.origin = {\n                    pos: !isBoundary ? circumCenter2(a, b, c) : ZERO2,\n                    id,\n                };\n                visitedVerts[id] = true;\n            }\n            work.push(e.sym, e.onext, e.lnext);\n        }\n    }\n    delaunay(bounds) {\n        const cells = [];\n        const usedEdges = {};\n        const bc = bounds && centroid(bounds);\n        this.traverse((eab) => {\n            if (!usedEdges[eab.id]) {\n                const ebc = eab.lnext;\n                const eca = ebc.lnext;\n                const va = eab.origin.pos;\n                const vb = ebc.origin.pos;\n                const vc = eca.origin.pos;\n                let verts = [va, vb, vc];\n                if (bounds &&\n                    !(pointInPolygon2(va, bounds) &&\n                        pointInPolygon2(vb, bounds) &&\n                        pointInPolygon2(vc, bounds))) {\n                    verts = sutherlandHodgeman(verts, bounds, bc);\n                    if (verts.length > 2) {\n                        cells.push(verts);\n                    }\n                }\n                else {\n                    cells.push(verts);\n                }\n                usedEdges[eab.id] = usedEdges[ebc.id] = usedEdges[eca.id] = true;\n            }\n        });\n        return cells;\n    }\n    voronoi(bounds) {\n        const cells = [];\n        const bc = bounds && centroid(bounds);\n        this.traverse(bounds\n            ? (e) => {\n                const first = (e = e.rot);\n                let verts = [];\n                let needsClip = false;\n                let p;\n                do {\n                    p = e.origin.pos;\n                    verts.push(p);\n                    needsClip = needsClip || !pointInPolygon2(p, bounds);\n                } while ((e = e.lnext) !== first);\n                if (needsClip) {\n                    verts = sutherlandHodgeman(verts, bounds, bc);\n                    if (verts.length < 3)\n                        return;\n                }\n                cells.push(verts);\n            }\n            : (e) => {\n                const first = (e = e.rot);\n                const verts = [];\n                do {\n                    verts.push(e.origin.pos);\n                } while ((e = e.lnext) !== first);\n                cells.push(verts);\n            }, false);\n        return cells;\n    }\n    edges(voronoi = false, boundsMinMax) {\n        const edges = [];\n        const visitedEdges = {};\n        this.traverse((e) => {\n            if (visitedEdges[e.id] || visitedEdges[e.sym.id])\n                return;\n            if (e.origin.id > 2 && e.dest.id > 2) {\n                const a = e.origin.pos;\n                const b = e.dest.pos;\n                if (boundsMinMax) {\n                    const clip = liangBarsky2(a, b, boundsMinMax[0], boundsMinMax[1]);\n                    clip && edges.push([clip[0], clip[1]]);\n                }\n                else {\n                    edges.push([a, b]);\n                }\n            }\n            visitedEdges[e.id] = true;\n        }, true, voronoi ? this.first.rot : this.first);\n        return edges;\n    }\n    traverse(proc, edges = true, e = this.first) {\n        const work = [e];\n        const visitedEdges = {};\n        const visitedVerts = {};\n        while (work.length) {\n            e = work.pop();\n            if (visitedEdges[e.id])\n                continue;\n            visitedEdges[e.id] = true;\n            const eoID = e.origin.id;\n            if (eoID > 2 && e.rot.origin.id > 2) {\n                if (edges || !visitedVerts[eoID]) {\n                    visitedVerts[eoID] = true;\n                    proc(e, visitedEdges, visitedVerts);\n                }\n            }\n            work.push(e.sym, e.onext, e.lnext);\n        }\n    }\n}\n\nexport { DVMesh };\n", "import { i as illegalArgs } from './distsq-d74f45eb.js';\n\nconst isArray = Array.isArray;\n\nconst OBJP = Object.getPrototypeOf({});\nconst FN = \"function\";\nconst STR = \"string\";\nconst equiv = (a, b) => {\n    let proto;\n    if (a === b) {\n        return true;\n    }\n    if (a != null) {\n        if (typeof a.equiv === FN) {\n            return a.equiv(b);\n        }\n    }\n    else {\n        return a == b;\n    }\n    if (b != null) {\n        if (typeof b.equiv === FN) {\n            return b.equiv(a);\n        }\n    }\n    else {\n        return a == b;\n    }\n    if (typeof a === STR || typeof b === STR) {\n        return false;\n    }\n    if (((proto = Object.getPrototypeOf(a)), proto == null || proto === OBJP) &&\n        ((proto = Object.getPrototypeOf(b)), proto == null || proto === OBJP)) {\n        return equivObject(a, b);\n    }\n    if (typeof a !== FN &&\n        a.length !== undefined &&\n        typeof b !== FN &&\n        b.length !== undefined) {\n        return equivArrayLike(a, b);\n    }\n    if (a instanceof Set && b instanceof Set) {\n        return equivSet(a, b);\n    }\n    if (a instanceof Map && b instanceof Map) {\n        return equivMap(a, b);\n    }\n    if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n    }\n    if (a instanceof RegExp && b instanceof RegExp) {\n        return a.toString() === b.toString();\n    }\n    // NaN\n    return a !== a && b !== b;\n};\nconst equivArrayLike = (a, b, _equiv = equiv) => {\n    let l = a.length;\n    if (l === b.length) {\n        while (--l >= 0 && _equiv(a[l], b[l]))\n            ;\n    }\n    return l < 0;\n};\nconst equivSet = (a, b, _equiv = equiv) => a.size === b.size && _equiv([...a.keys()].sort(), [...b.keys()].sort());\nconst equivMap = (a, b, _equiv = equiv) => a.size === b.size && _equiv([...a].sort(), [...b].sort());\nconst equivObject = (a, b, _equiv = equiv) => {\n    if (Object.keys(a).length !== Object.keys(b).length) {\n        return false;\n    }\n    for (let k in a) {\n        if (!b.hasOwnProperty(k) || !_equiv(a[k], b[k])) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\n * Attempts to obtain an iterator from `x` and throws error if `x` is\n * not iterable.\n *\n * @param x -\n */\nconst ensureIterable = (x) => {\n    (x == null || !x[Symbol.iterator]) &&\n        illegalArgs(`value is not iterable: ${x}`);\n    return x;\n};\n\n/**\n * Helper function to avoid unnecessary copying if `x` is already an\n * array.\n *\n * @remarks\n * First checks if `x` is an array and if so returns it. Else attempts\n * to obtain an iterator from `x` and if successful collects it as array\n * and returns it. Throws error if `x` isn't iterable.\n *\n * @param x -\n */\nconst ensureArray = (x) => isArray(x) ? x : [...ensureIterable(x)];\n\nexport { equiv as a, ensureArray as e, isArray as i };\n", "import { q as defMathOpN, E as EPS, B as defHofOp } from './codegen-df7bb22c.js';\nimport { c as magSq, s as set } from './set-c051c4f9.js';\n\nconst INV_MAX = 1 / 0xffffffff;\nclass ARandom {\n    float(norm = 1) {\n        return this.int() * INV_MAX * norm;\n    }\n    norm(norm = 1) {\n        return (this.int() * INV_MAX - 0.5) * 2 * norm;\n    }\n    minmax(min, max) {\n        return this.float() * (max - min) + min;\n    }\n}\n\nconst random = Math.random;\n/**\n * A `Math.random()` based {@link IRandom} implementation. Also @see\n * {@link SYSTEM}.\n */\nclass SystemRandom extends ARandom {\n    int() {\n        return (random() * 4294967296) /* 2**32 */ >>> 0;\n    }\n    float(norm = 1) {\n        return random() * norm;\n    }\n    norm(norm = 1) {\n        return (random() - 0.5) * 2 * norm;\n    }\n}\n/**\n * Used as default PRNG throughout most other thi.ng projects, though usually is\n * configurable.\n */\nconst SYSTEM = new SystemRandom();\n\nconst [mulN, mulN2, mulN3, mulN4] = defMathOpN(\"*\");\n\nconst mag = (v) => Math.sqrt(magSq(v));\n\n/**\n * Normalizes vector to given (optional) length (default: 1). If `out`\n * is null, modifies `v` in place.\n *\n * @param out -\n * @param v -\n * @param n -\n */\nconst normalize = (out, v, n = 1) => {\n    !out && (out = v);\n    const m = mag(v);\n    return m >= EPS ? mulN(out, v, n / m) : out !== v ? set(out, v) : out;\n};\n\n/**\n * Sets `v` to random vector, with each component in interval `[n..m)`.\n * If no `rnd` instance is given, uses {@link @thi.ng/random#SYSTEM},\n * i.e. `Math.random`.\n * Creates new vector if `v` is null.\n *\n * @param v -\n * @param n - default -1\n * @param m - default 1\n * @param rnd -\n */\nconst [random$1, random2, random3, random4] = defHofOp(SYSTEM, ([a]) => `${a}=rnd.minmax(n,m);`, \"a,n=-1,m=1,rnd=op\", \"a\", \"a\", 0, \"!a && (a=[]);\");\nconst $norm = (random) => (v, n = 1, rnd = SYSTEM) => normalize(random((v = v || []), -1, 1, rnd), v, n);\n/**\n * Sets `v` to a random vector, normalized to length `n` (default: 1). If\n * no `rnd` instance is given, uses {@link @thi.ng/random#SYSTEM}, i.e.\n * `Math.random`.\n *\n * @param v -\n * @param n -\n * @param rnd -\n */\nconst randNorm = $norm(random$1);\n/**\n * Sets `out` to random vector with each component in the semi-open\n * interval defined by [min,max).\n *\n * @param out -\n * @param min -\n * @param max -\n * @param rnd -\n */\nconst [randMinMax, randMinMax2, randMinMax3, randMinMax4] = defHofOp(SYSTEM, ([o, a, b]) => `${o}=rnd.minmax(${a},${b});`, \"o,a,b,rnd=op\", \"o,a,b\");\n\nexport { SYSTEM as S, mulN2 as a, mag as b, mulN3 as c, randNorm as d, randMinMax2 as e, mulN as m, normalize as n, randMinMax as r };\n", "import { i as isNumber, a as add3, b as add2, c as add } from '../common/add-5cc35f4d.js';\nimport { s as set, a as set2, b as set3, m as magSq2, c as magSq } from '../common/set-c051c4f9.js';\nimport { e as ensureArray, a as equiv, i as isArray } from '../common/ensure-array-575b2a26.js';\nimport { d as defError, N as NO_OP, r as reduce, a as reducer, c as compR, u as unreduced, i as isReduced, e as ensureReduced, D as DEG2RAD, P as PI, T as TAU, E as EPS, b as isIterable, f as iterator1, g as iterator, h as comp, m as map, $ as $iter, j as mapIndexed, k as defFnOp, l as defOp, A as ARGS_VV, n as ARGS_VNV, M as MATH2A_N, o as ARGS_VVN, p as MATH2_N, q as defMathOpN, v as vop, s as implementsFunction, t as defMathOp, w as compile, S as SARGS_V, x as DOT, y as ARGS_VVV, z as MATH2, F as FN2, B as defHofOp, C as ARGS_VN, G as FN_N, H as HALF_PI, I as SQRT2_2, J as THIRD_PI, K as unsupported, L as transduce, O as zip, Q as push, R as SQRT3, U as isArrayLike } from '../common/codegen-df7bb22c.js';\nimport { c as clamp01, i as inRange, d as dot, s as sub, Z as ZERO2, a as ZERO3, b as sub3, M as MAX2, e as MIN2, f as eqDelta2, g as sub2, X as X2, h as clamp, m as mixN, j as closestPointPolyline, k as closestPointSegment, l as closestT, n as eqDelta, o as farthestPointSegment, p as mixN2, q as circumCenter2, r as corner2, I as IntersectionType, t as eqDelta$1, u as dot3, v as sign, w as pointInPolygon2, x as liangBarsky2, z as zeroes, y as Z3$1, A as centroid$1, B as signedArea2, C as MIN3, D as MAX3, E as divN, F as classifyPointInCircle, G as classifyPointInTriangle2, H as sutherlandHodgeman, J as minNonZero2, K as minNonZero3, L as intersectLineLine, N as pointInAABB, O as pointInCircle, P as pointInSegment, Q as isInArray, R as pointInRect, S as pointInTriangle2 } from '../common/index-e6512bd8.js';\nimport { m as mulN, n as normalize$1, a as mulN2, b as mag, c as mulN3, S as SYSTEM, r as randMinMax } from '../common/random-15d3d7f2.js';\nimport { i as illegalArgs, d as distSq, a as distSq2 } from '../common/distsq-d74f45eb.js';\n\nconst isFunction = (x) => typeof x === \"function\";\n\nconst isString = (x) => typeof x === \"string\";\n\nvar process = {};\n\nconst isNotStringAndIterable = (x) => x != null &&\n    typeof x !== \"string\" &&\n    typeof x[Symbol.iterator] === \"function\";\n\nconst OBJP = Object.getPrototypeOf;\n/**\n * Similar to {@link isObject}, but also checks if prototype is that of\n * `Object` (or `null`).\n *\n * @param x -\n */\nconst isPlainObject = (x) => {\n    let p;\n    return (x != null &&\n        typeof x === \"object\" &&\n        ((p = OBJP(x)) === null || OBJP(p) === null));\n};\n\nfunction memoizeJ(fn, cache) {\n    !cache && (cache = {});\n    return (...args) => {\n        const key = JSON.stringify(args);\n        if (key !== undefined) {\n            return key in cache\n                ? cache[key]\n                : (cache[key] = fn.apply(null, args));\n        }\n        return fn.apply(null, args);\n    };\n}\n\n/**\n * @param ch - character\n * @param n - repeat count\n */\nconst repeat = memoizeJ((ch, n) => ch.repeat(n));\n\n/**\n * Hex digits\n */\nconst HEX = \"0123456789abcdef\";\n/**\n * Returns 8bit uint as hex string\n *\n * @param x\n */\nconst U8 = (x) => HEX[(x >>> 4) & 0xf] + HEX[x & 0xf];\n/**\n * Returns 16bit uint as hex string\n *\n * @param x\n */\nconst U16 = (x) => U8(x >>> 8) + U8(x & 0xff);\n/**\n * Returns 24bit uint as hex string\n *\n * @param x\n */\nconst U24 = (x) => U8(x >>> 16) + U16(x);\n\n/**\n * Returns a {@link Stringer} which formats given numbers to `radix`, `len` and\n * with optional prefix (not included in `len`).\n *\n * @remarks\n * Only bases 2 - 36 are supported, due to native `Number.toString()`\n * limitations.\n *\n * @param radix -\n * @param len -\n * @param prefix -\n */\nconst radix = memoizeJ((radix, n, prefix = \"\") => {\n    const buf = repeat(\"0\", n);\n    return (x) => {\n        x = (x >>> 0).toString(radix);\n        return prefix + (x.length < n ? buf.substr(x.length) + x : x);\n    };\n});\n/**\n * 8bit binary conversion preset.\n */\nconst B8 = radix(2, 8);\n/**\n * 16bit binary conversion preset.\n */\nconst B16 = radix(2, 16);\n/**\n * 32bit binary conversion preset.\n */\nconst B32 = radix(2, 32);\n/**\n * 24bit hex conversion preset.\n * Assumes unsigned inputs.\n */\nconst U24$1 = U24;\n\n/**\n * @param n - target length\n * @param ch - pad character(s)\n */\nconst padLeft = memoizeJ((n, ch = \" \") => {\n    const buf = repeat(String(ch), n);\n    return (x, len) => {\n        if (x == null)\n            return buf;\n        x = x.toString();\n        len = len !== undefined ? len : x.length;\n        return len < n ? buf.substr(len) + x : x;\n    };\n});\n/**\n * Zero-padded 2 digit formatter.\n */\nconst Z2 = padLeft(2, \"0\");\n/**\n * Zero-padded 3 digit formatter.\n */\nconst Z3 = padLeft(3, \"0\");\n/**\n * Zero-padded 4 digit formatter.\n */\nconst Z4 = padLeft(4, \"0\");\n\n/**\n * Returns {@link Stringer} which formats numbers to given precision. If\n * `special` is true, then exceptional handling for:\n *\n * - NaN => \"NaN\"\n * - Infinity => \"+/-\"\n *\n * @param len - number of fractional digits\n * @param special - true, if special handling for NaN/Infinity values\n */\nconst float = memoizeJ((prec, special = false) => special\n    ? (x) => nanOrInf(x) || x.toFixed(prec)\n    : (x) => x.toFixed(prec));\n/**\n * Similar to `float`, returns {@link Stringer} which formats numbers to given\n * character width & precision. Uses scientific notation if needed.\n *\n * Default precision: 3 fractional digits\n */\nconst floatFixedWidth = memoizeJ((width, prec = 3) => {\n    const l = width - prec - 1;\n    const pl = Math.pow(10, l);\n    const pln = -Math.pow(10, l - 1);\n    const pr = Math.pow(10, -(prec - 1));\n    const pad = padLeft(width);\n    return (x) => {\n        const ax = Math.abs(x);\n        return pad(nanOrInf(x) ||\n            (x === 0\n                ? \"0\"\n                : ax < pr || ax >= pl\n                    ? exp(x, width)\n                    : x.toFixed(prec - (x < pln ? 1 : 0))));\n    };\n});\nconst exp = (x, w) => x.toExponential(Math.max(w -\n    4 -\n    (Math.log(Math.abs(x)) / Math.LN10 >= 10 ? 2 : 1) -\n    (x < 0 ? 1 : 0), 0));\nconst nanOrInf = (x) => isNaN(x)\n    ? \"NaN\"\n    : x === Infinity\n        ? \"+\"\n        : x === -Infinity\n            ? \"-\"\n            : undefined;\n\n/**\n * Yields iterator of characters [`from`..`to`] (inclusive). Uses\n * reverse ordering if `to` < `from`.\n *\n * @param from -\n * @param to -\n */\nfunction* charRange(from, to) {\n    let i = typeof from === \"string\" ? from.charCodeAt(0) : from;\n    const end = typeof to === \"string\" ? to.charCodeAt(0) : to;\n    if (i <= end) {\n        for (; i <= end; i++) {\n            yield String.fromCharCode(i);\n        }\n    }\n    else {\n        for (; i >= end; i--) {\n            yield String.fromCharCode(i);\n        }\n    }\n}\n\nconst defGroup = (...xs) => {\n    const acc = {};\n    for (let range of xs) {\n        for (let c of range) {\n            acc[c] = true;\n        }\n    }\n    return Object.freeze(acc);\n};\n/**\n * Object with whitespace characters as keys and their values set to\n * true. All others undefined.\n */\nconst WS = Object.freeze({\n    \"\\t\": true,\n    \"\\n\": true,\n    \"\\v\": true,\n    \"\\f\": true,\n    \"\\r\": true,\n    \" \": true,\n});\n/**\n * Object with 0-9 characters as keys and their values set to true. All\n * others undefined.\n */\nconst DIGITS = defGroup(charRange(\"0\", \"9\"));\n/**\n * Object with hex digit characters (upper & lower case versions) as\n * keys and their values set to true. All others undefined.\n */\nconst HEX$1 = defGroup(charRange(\"0\", \"9\"), charRange(\"A\", \"F\"), charRange(\"a\", \"f\"));\n/**\n * Object with ASCII lowercase characters as keys and their values set\n * to true. All others undefined.\n */\nconst LOWER = defGroup(charRange(\"a\", \"z\"));\n/**\n * Object with ASCII uppercase characters as keys and their values set\n * to true. All others undefined.\n */\nconst UPPER = defGroup(charRange(\"A\", \"Z\"));\n/**\n * Combination of {@link UPPER} and {@link LOWER}.\n */\nconst ALPHA = Object.freeze(Object.assign(Object.assign({}, UPPER), LOWER));\n/**\n * Combination of {@link ALPHA} and {@link DIGITS} and '_'.\n */\nconst ALPHA_NUM = Object.freeze(Object.assign(Object.assign(Object.assign({}, ALPHA), DIGITS), { _: true }));\n/**\n * Object with ASCII punctuation characters as keys and their values set\n * to true. All others undefined.\n */\nconst PUNCTUATION = defGroup(charRange(\"!\", \"/\"), charRange(\":\", \"@\"), charRange(\"[\", \"`\"), charRange(\"{\", \"~\"));\n\nconst IllegalStateError = defError(() => \"illegal state\");\nconst illegalState = (msg) => {\n    throw new IllegalStateError(msg);\n};\n\n/**\n * Returns {@link Stringer} which formats given fractions as percentage (e.g.\n * `0.1234 => 12.34%`).\n *\n * @param prec - number of fractional digits (default: 0)\n */\nconst percent = (prec = 0) => (x) => (x * 100).toFixed(prec) + \"%\";\n\n/**\n * Returns true iff `x` implements {@link IDeref}.\n *\n * @param x\n */\nconst isDeref = (x) => x != null && typeof x[\"deref\"] === \"function\";\n/**\n * If `x` implements {@link IDeref}, returns its wrapped value, else\n * returns `x` itself.\n *\n * @param x -\n */\nconst deref = (x) => (isDeref(x) ? x.deref() : x);\n\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"FINE\"] = 0] = \"FINE\";\n    LogLevel[LogLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"SEVERE\"] = 4] = \"SEVERE\";\n    LogLevel[LogLevel[\"NONE\"] = 5] = \"NONE\";\n})(LogLevel || (LogLevel = {}));\n\n/**\n * Takes a `test` result or predicate function without args and throws\n * error with given `msg` if test failed (i.e. is falsy).\n *\n * @remarks\n * The function is only enabled if `\"production\" != \"production\"`\n * or if the `UMBRELLA_ASSERTS` env var is set to 1.\n */\nconst assert = (() => {\n    try {\n        return (\"production\" !== \"production\" ||\n            process.env.UMBRELLA_ASSERTS === \"1\");\n    }\n    catch (e) { }\n    return false;\n})()\n    ? (test, msg = \"assertion failed\") => {\n        if ((typeof test === \"function\" && !test()) || !test) {\n            throw new Error(typeof msg === \"function\" ? msg() : msg);\n        }\n    }\n    : NO_OP;\n\nconst NULL_LOGGER = Object.freeze({\n    level: LogLevel.NONE,\n    fine() { },\n    debug() { },\n    info() { },\n    warn() { },\n    severe() { },\n});\n\nfunction last(xs) {\n    return xs ? reduce(last(), xs) : reducer(NO_OP, (_, x) => x);\n}\n\n/**\n * Transducer to concatenate iterable values. Iterates over each input\n * and emits individual values down stream, therefore removing one level\n * of nesting from the input.\n *\n * @remarks\n * If, during processing, the transducer is given a wrapped reduced\n * input iterable, it will still be processed as normal, but then\n * immediately triggers early termination by wrapping its own result in\n * {@link reduced}. E.g. this behavior allows a {@link (mapcat:1)} user\n * functions to benefit from reduced results.\n *\n * Also see:\n * - {@link concat}\n * - {@link (mapcat:1)}\n *\n * @example\n * ```ts\n * [...iterator(comp(map((x) => [x, x]), cat()), [1, 2, 3, 4])]\n * // [ 1, 1, 2, 2, 3, 3, 4, 4 ]\n *\n * [...iterator(\n *   comp(\n *     mapIndexed((i, x) => [[i], [x, x]]),\n *     cat(),\n *     cat()\n *   ),\n *   \"abc\"\n * )]\n * // [ 0, 'a', 'a', 1, 'b', 'b', 2, 'c', 'c' ]\n *\n * [...mapcat((x)=>(x > 1 ? reduced([x, x]) : [x, x]), [1, 2, 3, 4])]\n * // [ 1, 1, 2, 2 ]\n * ```\n *\n * @param rfn -\n */\nconst cat = () => (rfn) => {\n    const r = rfn[2];\n    return compR(rfn, (acc, x) => {\n        if (x) {\n            for (let y of unreduced(x)) {\n                acc = r(acc, y);\n                if (isReduced(acc)) {\n                    break;\n                }\n            }\n        }\n        return isReduced(x) ? ensureReduced(acc) : acc;\n    });\n};\n\n/**\n * Returns vector of `[sin(theta)*n, cos(theta)*n]`.\n *\n * @param theta -\n * @param n -\n */\nconst sincos = (theta, n = 1) => [\n    Math.sin(theta) * n,\n    Math.cos(theta) * n,\n];\n/**\n * Returns vector of `[cos(theta)*n, sin(theta)*n]`.\n *\n * @param theta -\n * @param n -\n */\nconst cossin = (theta, n = 1) => [\n    Math.cos(theta) * n,\n    Math.sin(theta) * n,\n];\nconst absInnerAngle = (theta) => ((theta = Math.abs(theta)), theta > PI ? TAU - theta : theta);\n/**\n * Converts angle to radians.\n *\n * @param theta - angle in degrees\n */\nconst rad = (theta) => theta * DEG2RAD;\n\nconst fit01 = (x, a, b) => a + (b - a) * clamp01(x);\n\n/**\n * Recursively evaluates function `fn` for `res` uniformly spaced values\n * `t` in the closed parametric interval `[start,end]` and computes\n * corresponding sample values `p`. For each `p` then calls `error`\n * function to compute the error to query target value `q` and\n * eventually returns the `t` producing the overall minimum error. At\n * each level of recursion the search interval is increasingly narrowed\n * / centered around the best `t` of the current iteration.\n *\n * The search is terminated early if the best error value is less than\n * `eps`.\n *\n * The interval end points `start` and `end` MUST be normalized values\n * in the closed [0,1] interval.\n *\n * @param fn - function to evaluate\n * @param error - error function\n * @param q - target value\n * @param res - number of samples per interval\n * @param iter - max number of iterations / recursion limit\n * @param start - interval start\n * @param end - interval end\n */\nconst minError = (fn, error, q, res = 16, iter = 8, start = 0, end = 1, eps = EPS) => {\n    if (iter <= 0)\n        return (start + end) / 2;\n    const delta = (end - start) / res;\n    let minT = start;\n    let minE = Infinity;\n    for (let i = 0; i <= res; i++) {\n        const t = start + i * delta;\n        const e = error(q, fn(t));\n        if (e < minE) {\n            if (e <= eps)\n                return t;\n            minE = e;\n            minT = t;\n        }\n    }\n    return minError(fn, error, q, res, iter - 1, Math.max(minT - delta, 0), Math.min(minT + delta, 1));\n};\n\n/**\n * Bilinear interpolation of given values (`a`,`b`,`c`,`d`).\n *\n * @example\n * ```ts\n * c    d\n * +----+\n * |    |\n * +----+\n * a    b\n * ```\n *\n * @param a - BL value\n * @param b - BR value\n * @param c - TL value\n * @param d - TR value\n * @param u - 1st interpolation factor\n * @param v - 2nd interpolation factor\n */\nconst mixBilinear = (a, b, c, d, u, v) => {\n    const iu = 1 - u;\n    const iv = 1 - v;\n    return a * iu * iv + b * u * iv + c * iu * v + d * u * v;\n};\nconst mixCubic = (a, b, c, d, t) => {\n    const t2 = t * t;\n    const s = 1 - t;\n    const s2 = s * s;\n    return a * s2 * s + b * 3 * s2 * t + c * 3 * t2 * s + d * t2 * t;\n};\n\nconst fract = (x) => x - Math.floor(x);\nconst roundTo = (x, prec = 1) => Math.round(x / prec) * prec;\n/**\n * Only rounds `x` to nearest int if `fract(x)` <= `eps` or >= `1-eps`.\n *\n * @param x -\n * @param eps -\n */\nconst roundEps = (x, eps = EPS) => {\n    const f = fract(x);\n    return f <= eps || f >= 1 - eps ? Math.round(x) : x;\n};\n\n/**\n * Returns `a` divided by `b` or zero if `b = 0`.\n *\n * @param a\n * @param b\n */\nconst safeDiv = (a, b) => (b !== 0 ? a / b : 0);\n\nfunction filter(pred, src) {\n    return isIterable(src)\n        ? iterator1(filter(pred), src)\n        : (rfn) => {\n            const r = rfn[2];\n            return compR(rfn, (acc, x) => (pred(x) ? r(acc, x) : acc));\n        };\n}\n\n/**\n * Returns first element of given array or `undefined` if array is empty.\n *\n * @param buf - array\n */\n/**\n * Returns last element of given array or `undefined` if array is empty.\n *\n * @param buf - array\n */\nconst peek = (buf) => buf[buf.length - 1];\n\n/**\n * Yields sequence of `n+1` monotonically increasing numbers in the\n * closed interval (0.0 .. 1.0). If `n <= 0`, yields nothing.\n *\n * @example\n * ```ts\n * [...normRange(4)]\n * // [0, 0.25, 0.5, 0.75, 1.0]\n * ```\n *\n * @param n - number of steps\n * @param includeLast - include last value (i.e. `1.0`)\n */\nfunction* normRange(n, includeLast = true) {\n    if (n > 0) {\n        for (let i = 0, m = includeLast ? n + 1 : n; i < m; i++) {\n            yield i / n;\n        }\n    }\n}\n\nfunction mapcat(fn, src) {\n    return isIterable(src) ? iterator(mapcat(fn), src) : comp(map(fn), cat());\n}\n\nfunction partition(...args) {\n    const iter = $iter(partition, args, iterator);\n    if (iter) {\n        return iter;\n    }\n    let size = args[0], all, step;\n    if (typeof args[1] == \"number\") {\n        step = args[1];\n        all = args[2];\n    }\n    else {\n        step = size;\n        all = args[1];\n    }\n    return ([init, complete, reduce]) => {\n        let buf = [];\n        let skip = 0;\n        return [\n            init,\n            (acc) => {\n                if (all && buf.length > 0) {\n                    acc = reduce(acc, buf);\n                    buf = [];\n                }\n                return complete(acc);\n            },\n            (acc, x) => {\n                if (skip <= 0) {\n                    if (buf.length < size) {\n                        buf.push(x);\n                    }\n                    if (buf.length === size) {\n                        acc = reduce(acc, buf);\n                        buf = step < size ? buf.slice(step) : [];\n                        skip = step - size;\n                    }\n                }\n                else {\n                    skip--;\n                }\n                return acc;\n            },\n        ];\n    };\n}\n\nfunction mapcatIndexed(...args) {\n    return ($iter(mapcatIndexed, args, iterator) ||\n        comp(mapIndexed(args[0], args[1]), cat()));\n}\n\nfunction scan(...args) {\n    return ((args.length > 2 && $iter(scan, args, iterator)) ||\n        (([inito, completeo, reduceo]) => {\n            const [initi, completei, reducei] = args[0];\n            let acc = args.length > 1 && args[1] != null ? args[1] : initi();\n            return [\n                inito,\n                (_acc) => {\n                    let a = completei(acc);\n                    if (a !== acc) {\n                        _acc = unreduced(reduceo(_acc, a));\n                    }\n                    acc = a;\n                    return completeo(_acc);\n                },\n                (_acc, x) => {\n                    acc = reducei(acc, x);\n                    if (isReduced(acc)) {\n                        return ensureReduced(reduceo(_acc, acc.deref()));\n                    }\n                    return reduceo(_acc, acc);\n                },\n            ];\n        }));\n}\n\n/**\n * Iterator which yields an infinite repetition of given `input`\n * iterable's values. Produces no values if `input` is empty. If `num`\n * is given, only that many cycles will be emitted.\n *\n * @remarks\n * Also see {@link repeat}, {@link repeatedly} for related functions.\n *\n * @example\n * ```ts\n * // take 5 from infinite sequence\n * [...take(5, cycle([1, 2, 3]))]\n * // [1, 2, 3, 1, 2]\n *\n * // only produce 2 cycles\n * [...cycle(range(3), 2)]\n * // [ 0, 1, 2, 0, 1, 2 ]\n * ```\n *\n * @param input -\n * @param num -\n */\nfunction* cycle(input, num = Infinity) {\n    if (num < 1)\n        return;\n    let cache = [];\n    for (let i of input) {\n        cache.push(i);\n        yield i;\n    }\n    if (cache.length > 0) {\n        while (--num > 0) {\n            yield* cache;\n        }\n    }\n}\n\n/**\n * Iterator yielding an infinite (by default) repetition of given value\n * `x`. If `n` is given, only produces that many values.\n *\n * See also: {@link repeatedly}\n *\n * @example\n * ```ts\n * [...repeat(42, 5)]\n * // [42, 42, 42, 42, 42]\n * ```\n *\n * @param x - value to repeat\n * @param n - num values (default: )\n */\nfunction* repeat$1(x, n = Infinity) {\n    while (n-- > 0) {\n        yield x;\n    }\n}\n\n/**\n * Yields iterator of `src` with the last `numLeft` values of `src`\n * prepended at the beginning and/or the first `numRight` values\n * appended at the end.\n *\n * @remarks\n * `numLeft` defaults to 1 and `numRight` defaults to same value as\n * `numLeft`, therefore wraps both sides by default and throws error if\n * either `nXXX < 0` or larger than `src.length`.\n *\n * See also:\n * - {@link extendSides}\n * - {@link padSides}\n *\n * @param src -\n * @param numLeft -\n * @param numRight -\n */\nfunction* wrapSides(src, numLeft = 1, numRight = numLeft) {\n    const _src = ensureArray(src);\n    !(inRange(numLeft, 0, _src.length) && inRange(numRight, 0, _src.length)) &&\n        illegalArgs(`allowed wrap range: [0..${_src.length}]`);\n    if (numLeft > 0) {\n        for (let m = _src.length, i = m - numLeft; i < m; i++) {\n            yield _src[i];\n        }\n    }\n    yield* _src;\n    if (numRight > 0) {\n        for (let i = 0; i < numRight; i++) {\n            yield _src[i];\n        }\n    }\n}\n\n/**\n * Extracts 16-bit lane from given 32bit uint and returns as unsigned\n * half word [0x0000 .. 0xffff].\n *\n * - Lane #0: bits 16-31\n * - Lane #1: bits 0-15\n *\n * @param x -\n * @param lane - lane ID enum\n */\n/**\n * Swaps bytes lanes 1 & 3 (i.e. bits 16-23 with bits 0-7)\n *\n * @param x\n */\nconst swapLane13 = (x) => ((x & 0xff) << 16) | ((x >> 16) & 0xff) | (x & 0xff00ff00);\n\nconst [abs, abs2, abs3, abs4] = defFnOp(\"Math.abs\");\n\n/**\n * Returns `out = a * n + b`.\n *\n * @param out - vec\n * @param a - vec\n * @param n - scalar\n * @param b - vec\n */\nconst [maddN, maddN2, maddN3, maddN4] = defOp(MATH2A_N(\"*\", \"+\"), ARGS_VNV, ARGS_VV);\n\nconst addW2 = (out, a, b, wa, wb) => (!out && (out = a), maddN(out, b, wb, mulN(out, a, wa)));\nconst addW3 = (out, a, b, c, wa, wb, wc) => (!out && (out = a), maddN(out, c, wc, maddN(out, b, wb, mulN(out, a, wa))));\nconst addW4 = (out, a, b, c, d, wa, wb, wc, wd) => (!out && (out = a),\n    maddN(out, d, wd, maddN(out, c, wc, maddN(out, b, wb, mulN(out, a, wa)))));\n\n/**\n * Returns `out = (a + b) * n`.\n */\nconst [addmN, addmN2, addmN3, addmN4] = defOp(MATH2_N(\"+\", \"*\"), ARGS_VVN);\n\nconst [addN, addN2, addN3, addN4] = defMathOpN(\"+\");\n\nconst setC2 = (out, x, y) => (!out && (out = []), (out[0] = x), (out[1] = y), out);\nconst setC3 = (out, x, y, z) => (!out && (out = []), (out[0] = x), (out[1] = y), (out[2] = z), out);\nconst setC4 = (out, x, y, z, w) => (!out && (out = []),\n    (out[0] = x),\n    (out[1] = y),\n    (out[2] = z),\n    (out[3] = w),\n    out);\nconst setC6 = (out, a, b, c, d, e, f) => (!out && (out = []),\n    (out[0] = a),\n    (out[1] = b),\n    (out[2] = c),\n    (out[3] = d),\n    (out[4] = e),\n    (out[5] = f),\n    out);\nconst setC = (out, ...xs) => {\n    !out && (out = []);\n    for (let i = 0, n = xs.length; i < n; i++) {\n        out[i] = xs[i];\n    }\n    return out;\n};\n\nconst cross2 = (a, b) => a[0] * b[1] - a[1] * b[0];\nconst cross3 = (out, a, b) => setC3(out || a, a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]);\n\nconst angleBetween2 = (a, b, absInner = false) => {\n    const t = Math.atan2(cross2(a, b), dot(a, b));\n    return absInner ? absInnerAngle(t) : t;\n};\n\n/**\n * Computes direction vector `a` -> `b`, normalized to length `n`\n * (default 1).\n *\n * @param a -\n * @param b -\n * @param n -\n */\nconst direction = (out, a, b, n = 1) => normalize$1(null, sub(out || a, b, a), n);\n\n/**\n * 2D only. Produces a perpendicular vector to `v`, i.e. `[-y,x]`.\n * Assumes positive Y-up.\n *\n * @param out -\n * @param v -\n */\nconst perpendicularCCW = (out, a) => setC2(out || a, -a[1], a[0]);\n/**\n * 2D only. Produces a clockwise perpendicular vector to `v`, i.e.\n * `[y,-x]`. Assumes positive Y-up.\n *\n * @param out -\n * @param v -\n */\nconst perpendicularCW = (out, a) => setC2(out || a, a[1], -a[0]);\n\n/**\n * Returns normalized bisector vector for point `b` in the triangle `a`\n * -> `b` -> `c`. If `out` is null, creates a new result vector. The `n`\n * arg can be used to scale the result vector to given length (default:\n * 1).\n *\n * @param out -\n * @param a -\n * @param b -\n * @param c -\n * @param n -\n */\nconst cornerBisector = (out, a, b, c, n = 1) => (!out && (out = []),\n    normalize$1(out, addmN(out, normalize$1(out, sub(out, a, b)), normalize$1(null, sub([], c, b)), 0.5), n));\n\nconst cos = Math.cos;\nconst sin = Math.sin;\n/**\n * Converts polar vector `v` to cartesian coordinates and adds optional\n * `offset`. See {@link polar} for reverse operation. If `out` is null,\n * modifies `v` in place.\n *\n * @param out -\n * @param v -\n * @param offset -\n */\nconst cartesian = vop(1);\n/**\n * Converts 2D polar vector `v` to cartesian coordinates and adds\n * optional `offset`. See {@link polar} for reverse operation. If `out` is\n * null, modifies `v` in place.\n *\n * @param out -\n * @param v -\n * @param offset -\n */\nconst cartesian2 = cartesian.add(2, (out, a, b = ZERO2) => maddN2(out || a, cossin(a[1]), a[0], b));\n/**\n * Converts 3D polar vector `v` to cartesian coordinates and adds\n * optional `offset`. See {@link polar} for reverse operation. If `out` is\n * null, modifies `v` in place.\n *\n * @param out -\n * @param v -\n * @param offset -\n */\nconst cartesian3 = cartesian.add(3, (out, a, b = ZERO3) => {\n    const r = a[0];\n    const theta = a[1];\n    const phi = a[2];\n    const ct = cos(theta);\n    return setC3(out || a, r * ct * cos(phi) + b[0], r * ct * sin(phi) + b[1], r * sin(theta) + b[2]);\n});\n\nconst [subN, subN2, subN3, subN4] = defMathOpN(\"-\");\n\nconst copy = (v) => implementsFunction(v, \"copy\") ? v.copy() : set([], v);\nconst copyVectors = (pts) => pts.map(copy);\n\nconst [mul, mul2, mul3, mul4] = defMathOp(\"*\");\n\nconst dist = (a, b) => Math.sqrt(distSq(a, b));\n\nconst [div, div2, div3, div4] = defMathOp(\"/\");\n\nconst $ = (dim) => compile(dim, DOT, `o,a,${SARGS_V}`, \"o,a\", \"\", \"+\", \"return \", \";\", true);\nconst dotS2 = $(2);\nconst dotS3 = $(3);\nconst dotS4 = $(4);\n\n/**\n * Returns `out = a * b + c`.\n *\n * - {@link addm}\n * - {@link maddN}\n *\n * @param out -\n * @param a -\n * @param b -\n * @param c -\n */\nconst [madd, madd2, madd3, madd4] = defOp(MATH2(\"*\", \"+\"), ARGS_VVV);\n\nconst [max, max2, max3, max4] = defOp(FN2(\"Math.max\"));\n\nconst [min, min2, min3, min4] = defOp(FN2(\"Math.min\"));\n\nconst [mixBilinear$1, mixBilinear2, mixBilinear3, mixBilinear4] = defHofOp(mixBilinear, ([o, a, b, c, d]) => `${o}=op(${a},${b},${c},${d},u,v);`, \"o,a,b,c,d,u,v\");\n\n/**\n * Vector version of {@link @thi.ng/math#mixCubic}.\n *\n * @param out - result\n * @param a -\n * @param b -\n * @param c -\n * @param d -\n * @param t - interpolation coeff [0..1]\n */\nconst mixCubic$1 = (out, a, b, c, d, t) => {\n    const s = 1 - t;\n    const s2 = s * s;\n    const t2 = t * t;\n    return addW4(out, a, b, c, d, s2 * s, 3 * s2 * t, 3 * t2 * s, t2 * t);\n};\n\n/**\n * Returns `out = (a - b) * n`.\n */\nconst [submN, submN2, submN3, submN4] = defOp(MATH2_N(\"-\", \"*\"), ARGS_VVN);\n\n/**\n * Vector version of {@link @thi.ng/math#mixQuadratic}.\n *\n * @param out - result\n * @param a -\n * @param b -\n * @param c -\n * @param t - interpolation coeff [0..1]\n */\nconst mixQuadratic = (out, a, b, c, t) => {\n    const s = 1 - t;\n    return addW3(out, a, b, c, s * s, 2 * s * t, t * t);\n};\n\nconst neg = (out, v) => mulN(out, v, -1);\n\n/**\n * Computes 2D normal by rotating direction vector `a` -> `b`, 90 deg\n * clockwise, normalized to length `n` (default: 1). If `out` is null,\n * creates new vector.\n *\n * @param out -\n * @param a -\n * @param b -\n * @param n -\n */\nconst normalCW = (out, a, b, n = 1) => perpendicularCW(null, direction(out || [], a, b, n));\n\n/**\n * Produces a vector which is perpendicular/normal to the plane spanned\n * by given 3 input vectors. If `normalize` is true (default), the\n * result vector will be normalized.\n *\n * @example\n * ```ts\n * orthoNormal3([], [0, 0, 0], [1, 0, 0], [0, 1, 0])\n * // [0, 0, 1]\n * ```\n *\n * @param out -\n * @param a -\n * @param b -\n * @param c -\n * @param normalize -\n */\nconst orthoNormal3 = (out, a, b, c, doNormalize = true) => {\n    out = cross3(null, sub3(out || a, b, a), sub3([], c, a));\n    return doNormalize ? normalize$1(out, out) : out;\n};\n\n/**\n * 2D version of {@link pointOnRay}.\n *\n * @param out -\n * @param rayOrigin -\n * @param rayDir -\n * @param dist -\n */\nconst pointOnRay2 = (out, rayOrigin, rayDir, dist) => maddN2(out, rayDir, dist, rayOrigin);\n/**\n * 3D version of {@link pointOnRay}.\n *\n * @param out -\n * @param rayOrigin -\n * @param rayDir -\n * @param dist -\n */\nconst pointOnRay3 = (out, rayOrigin, rayDir, dist) => maddN3(out, rayDir, dist, rayOrigin);\n\nconst [powN, powN2, powN3, powN4] = defOp(FN_N(\"Math.pow\"), ARGS_VN);\n\nconst _rotate = (u, v) => (out, a, theta) => {\n    out ? out !== a && set(out, a) : (out = a);\n    const s = Math.sin(theta);\n    const c = Math.cos(theta);\n    const x = a[u];\n    const y = a[v];\n    out[u] = x * c - y * s;\n    out[v] = x * s + y * c;\n    return out;\n};\nconst rotateZ = _rotate(0, 1);\n\nconst copyAttribs = ($) => (Object.assign({}, $.attribs));\n\nclass AABB {\n    constructor(pos = [0, 0, 0], size = 1, attribs) {\n        this.pos = pos;\n        this.attribs = attribs;\n        this.size = isNumber(size) ? [size, size, size] : size;\n    }\n    get type() {\n        return \"aabb\";\n    }\n    copy() {\n        return new AABB(set([], this.pos), set([], this.size), copyAttribs(this));\n    }\n    max() {\n        return add3([], this.pos, this.size);\n    }\n}\n\nclass APC {\n    constructor(points = [], attribs) {\n        this.points = points;\n        this.attribs = attribs;\n    }\n    *[Symbol.iterator]() {\n        yield* this.points;\n    }\n}\n\nconst pointAt = (pos, r, axis, start, end, t, out = []) => pointAtTheta(pos, r, axis, fit01(t, start, end), out);\nconst pointAtTheta = (pos, r, axis, theta, out = []) => add2(null, rotateZ(null, mul2(out, cossin(theta), r), axis), pos);\n\nconst bounds = (pos, r, axis, start, end) => {\n    const min = set2([], MAX2);\n    const max = set2([], MIN2);\n    const p = [];\n    const update = (theta) => {\n        pointAtTheta(pos, r, axis, theta, p);\n        min2(null, min, p);\n        max2(null, max, p);\n    };\n    update(start);\n    update(end);\n    if (start > end) {\n        const t = start;\n        start = end;\n        end = t;\n    }\n    // include multiples of /2 within [start,end] interval\n    for (let i = roundTo(start, HALF_PI), j = roundTo(end, HALF_PI); i < j; i += HALF_PI) {\n        inRange(i, start, end) && update(i);\n    }\n    return [min, max];\n};\n\nconst closestPoint = (p, o, r, axis, start, end, out = [], res, iter) => {\n    const fn = (t) => pointAtTheta(o, r, axis, fit01(t, start, end), out);\n    return fn(minError(fn, distSq2, p, res, iter));\n};\n\n/**\n * Conversion from endpoint to center parameterization.\n *\n * {@link https://svgwg.org/svg2-draft/implnote.html#ArcConversionEndpointToCenter}\n *\n * Returns undefined if `a` & `b` are equal or any `radii` component is\n * zero.\n *\n * @param a - start point\n * @param b - end point\n * @param radii - ellipse radii\n * @param axis - in radians\n * @param xl - large arc flag\n * @param cw - clockwise flag\n */\nconst fromEndPoints = (a, b, radii, axis = 0, xl = false, cw = false) => {\n    const r = abs2([], radii);\n    if (eqDelta2(a, b) || r[0] < EPS || r[1] < EPS) {\n        return;\n    }\n    axis %= TAU;\n    const d = submN2([], a, b, 0.5);\n    const c = Math.cos(axis);\n    const s = Math.sin(axis);\n    // transformed point\n    const tp = [c * d[0] + s * d[1], -s * d[0] + c * d[1]];\n    const [tx2, ty2] = powN2([], tp, 2);\n    // ensure radii\n    const rc = tx2 / (r[0] * r[0]) + ty2 / (r[1] * r[1]);\n    rc > 1 && mulN2(r, r, Math.sqrt(rc));\n    const [rx, ry] = r;\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n    // transformed center\n    const radicant = Math.max(0, (rx2 * ry2 - rx2 * ty2 - ry2 * tx2) / (rx2 * ty2 + ry2 * tx2));\n    const coeff = (xl !== cw ? 1 : -1) * Math.sqrt(radicant);\n    const tc = [coeff * ((rx * tp[1]) / ry), coeff * (-(ry * tp[0]) / rx)];\n    // actual center\n    const center = [\n        c * tc[0] - s * tc[1] + (a[0] + b[0]) / 2,\n        s * tc[0] + c * tc[1] + (a[1] + b[1]) / 2,\n    ];\n    // transformed end points & angles\n    const ta = div2(null, sub2([], tp, tc), r);\n    const tb = div2(null, sub2(null, neg([], tp), tc), r);\n    const start = angleBetween2(X2, ta);\n    let sweep = angleBetween2(ta, tb);\n    if (!cw && sweep > 0) {\n        sweep -= TAU;\n    }\n    else if (cw && sweep < 0) {\n        sweep += TAU;\n    }\n    sweep %= TAU;\n    return {\n        center,\n        r,\n        axis,\n        start,\n        end: start + sweep,\n        xl,\n        cw,\n    };\n};\n\nlet DEFAULT_SAMPLES = 20;\n\nconst closestPointRect = (p, bmin, bmax, out = []) => {\n    const [minID, minW] = closestBoxEdge(p, bmin, bmax, 4);\n    return minID === 0\n        ? setC2(out, minW, clamp(p[1], bmin[1], bmax[1]))\n        : setC2(out, clamp(p[0], bmin[0], bmax[0]), minW);\n};\nconst closestPointAABB = (p, bmin, bmax, out = []) => {\n    const [minID, minW] = closestBoxEdge(p, bmin, bmax, 6);\n    return minID === 0\n        ? setC3(out, minW, clamp(p[1], bmin[1], bmax[1]), clamp(p[2], bmin[2], bmax[2]))\n        : minID === 1\n            ? setC3(out, clamp(p[0], bmin[0], bmax[0]), minW, clamp(p[2], bmin[2], bmax[2]))\n            : setC3(out, clamp(p[0], bmin[0], bmax[0]), clamp(p[1], bmin[1], bmax[1]), minW);\n};\nconst closestBoxEdge = (p, bmin, bmax, n) => {\n    let minD = Infinity;\n    let minID;\n    let minW;\n    for (let i = 0; i < n; i++) {\n        const j = i >> 1;\n        const w = (i & 1 ? bmax : bmin)[j];\n        const d = Math.abs(p[j] - w);\n        if (d < minD) {\n            minD = d;\n            minID = j;\n            minW = w;\n        }\n    }\n    return [minID, minW];\n};\n\n/**\n * Returns closest point to `p` on circle defined by origin `c` and radius `r`.\n *\n * @param p\n * @param c\n * @param r\n * @param out\n */\nconst closestPointCircle = (p, c, r, out = []) => add(out, c, direction(out, c, p, r));\n\n/**\n * Returns signed distance between point `p` and plane defined by normal `n` and\n * `w`. In 2D this also works for lines.\n *\n * @remarks\n * If result is > 0 the point lies \"above\" the plane, if < 0 below the plane or\n * if zero on the plane.\n *\n * @param p\n * @param n\n * @param w\n */\nconst distToPlane = (p, n, w) => dot(n, p) - w;\n/**\n * Returns closest point to `p` on the plane defined by normal `n` and `w`. In\n * 2D this also works for lines.\n *\n * @param p\n * @param normal\n * @param w\n * @param out\n */\nconst closestPointPlane = (p, normal, w, out = []) => sub(out, p, normalize$1(out, normal, distToPlane(p, normal, w)));\n\n/**\n * Returns closest point to `p` in given point array, optionally using custom\n * distance function `dist` (default: {@link @thi.ng/vectors#distSq}).\n *\n * @param p\n * @param pts\n * @param out\n * @param dist\n */\nconst closestPointArray = (p, pts, out = [], dist = distSq) => {\n    let minD = Infinity;\n    let closest;\n    for (let i = pts.length; --i >= 0;) {\n        const d = dist(pts[i], p);\n        if (d < minD) {\n            minD = d;\n            closest = pts[i];\n        }\n    }\n    return closest ? set(out, closest) : undefined;\n};\n\nclass Sampler {\n    constructor(points, closed = false) {\n        if (closed) {\n            this.points = points.slice();\n            this.points.push(points[0]);\n        }\n        else {\n            this.points = points;\n        }\n        this.buildIndex();\n    }\n    totalLength() {\n        const idx = this.index;\n        return idx ? idx[idx.length - 1] : 0;\n    }\n    pointAt(t) {\n        const pts = this.points;\n        const n = pts.length - 1;\n        if (n < 0) {\n            return;\n        }\n        if (n === 0 || t <= 0) {\n            return pts[0];\n        }\n        if (t >= 1) {\n            return pts[n];\n        }\n        const idx = this.index;\n        const t0 = t * idx[n];\n        for (let i = 1; i <= n; i++) {\n            if (idx[i] >= t0) {\n                return mixN([], pts[i - 1], pts[i], (t0 - idx[i - 1]) / (idx[i] - idx[i - 1]));\n            }\n        }\n    }\n    closestPoint(p) {\n        return closestPointPolyline(p, this.points);\n    }\n    closestT(p) {\n        const { index, points } = this;\n        const tmp = [];\n        const closest = [];\n        let minD = Infinity;\n        let minI = -1;\n        for (let i = 0, n = index.length - 1; i < n; i++) {\n            if (closestPointSegment(p, points[i], points[i + 1], tmp)) {\n                const d = distSq(p, tmp);\n                if (d < minD) {\n                    minD = d;\n                    minI = i;\n                    set(closest, tmp);\n                }\n            }\n        }\n        return minI >= 0\n            ? fit01(closestT(p, points[minI], points[minI + 1]) || 0, index[minI], index[minI + 1]) / this.totalLength()\n            : undefined;\n    }\n    segmentAt(t) {\n        let i = this.indexAt(t);\n        if (i === undefined) {\n            return;\n        }\n        i = Math.max(1, i);\n        return [this.points[i - 1], this.points[i]];\n    }\n    tangentAt(t, n = 1) {\n        const seg = this.segmentAt(t);\n        return seg ? normalize$1(null, sub([], seg[1], seg[0]), n) : undefined;\n    }\n    splitAt(t) {\n        if (t <= 0 || t >= 1) {\n            return [this.points];\n        }\n        const p = this.pointAt(t);\n        if (!p)\n            return;\n        const i = Math.max(1, this.indexAt(t));\n        const head = this.points.slice(0, i);\n        const tail = this.points.slice(i);\n        if (!eqDelta(head[i - 1], p)) {\n            head.push(p);\n        }\n        if (!eqDelta(tail[0], p)) {\n            tail.unshift(p);\n        }\n        return [head, tail];\n    }\n    splitNear(p) {\n        const t = this.closestT(p);\n        return t !== undefined ? this.splitAt(t) : undefined;\n    }\n    indexAt(t) {\n        const pts = this.points;\n        const n = pts.length - 1;\n        if (n < 0) {\n            return;\n        }\n        if (n === 0 || t <= 0) {\n            return 0;\n        }\n        if (t >= 1) {\n            return n;\n        }\n        const idx = this.index;\n        const t0 = t * idx[n];\n        for (let i = 1; i <= n; i++) {\n            if (idx[i] >= t0) {\n                return i;\n            }\n        }\n    }\n    sampleUniform(dist, includeLast = false, result = []) {\n        const { index, points } = this;\n        const total = this.totalLength();\n        const delta = dist / total;\n        const n = index.length;\n        for (let t = 0, i = 1; t < 1; t += delta) {\n            const ct = t * total;\n            while (ct >= index[i] && i < n) {\n                i++;\n            }\n            if (i >= n)\n                break;\n            const p = index[i - 1];\n            result.push(mixN([], points[i - 1], points[i], (ct - p) / (index[i] - p)));\n        }\n        if (includeLast) {\n            result.push(set([], points[points.length - 1]));\n        }\n        return result;\n    }\n    sampleFixedNum(num, includeLast = false, result) {\n        return this.sampleUniform(this.totalLength() / num, includeLast, result);\n    }\n    buildIndex() {\n        const idx = [0];\n        const pts = this.points;\n        const n = pts.length;\n        for (let i = 0, j = 1; j < n; i = j, j++) {\n            idx[j] = idx[i] + dist(pts[i], pts[j]);\n        }\n        this.index = idx;\n    }\n}\n\nconst resample = (pts, opts, closed = false, copy = false) => {\n    if (opts !== undefined) {\n        const sampler = new Sampler(pts, closed);\n        return isPlainObject(opts)\n            ? closed\n                ? opts.dist\n                    ? sampler.sampleUniform(opts.dist, opts.last)\n                    : sampler.sampleFixedNum(opts.num || DEFAULT_SAMPLES, opts.last)\n                : opts.dist\n                    ? sampler.sampleUniform(opts.dist, opts.last !== false)\n                    : sampler.sampleFixedNum(opts.num || DEFAULT_SAMPLES, opts.last !== false)\n            : sampler.sampleFixedNum(opts || DEFAULT_SAMPLES, !closed);\n    }\n    return copy ? copyVectors(pts) : pts;\n};\n\n/**\n * {@link https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm}\n *\n * @param pts - points\n * @param eps - simplify threshold\n * @param closed - true, if closed shape (polygon)\n */\nconst simplify = (pts, eps = 0, closed = false) => {\n    let num = pts.length;\n    const visited = [];\n    if (num <= 2)\n        return pts.slice();\n    if (closed && !eqDelta(pts[0], pts[num - 1], EPS)) {\n        pts = pts.slice();\n        pts.push(pts[0]);\n        num++;\n    }\n    const $ = (from, to) => {\n        visited[from] = visited[to] = true;\n        if (to <= from + 1) {\n            return;\n        }\n        const [maxIdx, maxD] = farthestPointSegment(pts[from], pts[to], pts, from + 1, to);\n        if (maxIdx < 0 || maxD <= eps) {\n            return;\n        }\n        $(from, maxIdx);\n        $(maxIdx, to);\n    };\n    $(0, num - 1);\n    const res = [];\n    for (let i = 0, n = closed ? num - 1 : num; i < n; i++) {\n        visited[i] && res.push(pts[i]);\n    }\n    return res;\n};\n\nconst sample = (pos, r, axis, start, end, opts) => {\n    if (isPlainObject(opts) && opts.dist !== undefined) {\n        return new Sampler(sample(pos, r, axis, start, end, opts.num || DEFAULT_SAMPLES)).sampleUniform(opts.dist, opts.last !== false);\n    }\n    opts = isNumber(opts)\n        ? { num: opts, last: true }\n        : Object.assign({ num: DEFAULT_SAMPLES }, opts);\n    let delta = end - start;\n    let num = opts.theta ? Math.round(delta / opts.theta) : opts.num;\n    delta /= num;\n    opts.last !== false && num++;\n    const pts = new Array(num);\n    for (let i = 0; i < num; i++) {\n        pts[i] = pointAtTheta(pos, r, axis, start + i * delta);\n    }\n    return pts;\n};\n\nclass Arc {\n    constructor(pos, r, axis, start, end, xl = false, cw = false, attribs) {\n        this.pos = pos;\n        this.r = r;\n        this.axis = axis;\n        this.start = start;\n        this.end = end;\n        this.xl = xl;\n        this.cw = cw;\n        this.attribs = attribs;\n    }\n    get type() {\n        return \"arc\";\n    }\n    copy() {\n        return new Arc(set([], this.pos), set([], this.r), this.axis, this.start, this.end, this.xl, this.cw, copyAttribs(this));\n    }\n    equiv(o) {\n        return (o instanceof Arc &&\n            equiv(this.pos, o.pos) &&\n            equiv(this.r, o.r) &&\n            this.start === o.start &&\n            this.end === o.end &&\n            this.axis === o.axis &&\n            this.xl === o.xl &&\n            this.cw &&\n            o.cw);\n    }\n    pointAt(t, out = []) {\n        return pointAt(this.pos, this.r, this.axis, this.start, this.end, t, out);\n    }\n    pointAtTheta(theta, out = []) {\n        return pointAtTheta(this.pos, this.r, this.axis, theta, out);\n    }\n    toHiccup() {\n        return [\n            \"path\",\n            this.attribs,\n            [[\"M\", this.pointAt(0)], ...this.toHiccupPathSegments()],\n        ];\n    }\n    toHiccupPathSegments() {\n        return [\n            [\n                \"A\",\n                this.r[0],\n                this.r[1],\n                this.axis,\n                this.xl,\n                this.cw,\n                this.pointAt(1),\n            ],\n        ];\n    }\n}\n\nclass Circle {\n    constructor(pos = [0, 0], r = 1, attribs) {\n        this.pos = pos;\n        this.r = r;\n        this.attribs = attribs;\n    }\n    get type() {\n        return \"circle\";\n    }\n    copy() {\n        return new Circle(set([], this.pos), this.r, copyAttribs(this));\n    }\n    toHiccup() {\n        return [\"circle\", this.attribs, this.pos, this.r];\n    }\n}\n\nconst copyShape = (ctor, inst) => new ctor(copyVectors(inst.points), copyAttribs(inst));\n\nclass Cubic extends APC {\n    get type() {\n        return \"cubic\";\n    }\n    copy() {\n        return copyShape(Cubic, this);\n    }\n    toHiccup() {\n        return [\n            \"path\",\n            this.attribs,\n            [[\"M\", this.points[0]], ...this.toHiccupPathSegments()],\n        ];\n    }\n    toHiccupPathSegments() {\n        const pts = this.points;\n        return [[\"C\", pts[1], pts[2], pts[3]]];\n    }\n}\n\nclass Ellipse {\n    constructor(pos = [0, 0], r = [1, 1], attribs) {\n        this.pos = pos;\n        this.attribs = attribs;\n        this.r = isNumber(r) ? [r, r] : r;\n    }\n    get type() {\n        return \"ellipse\";\n    }\n    copy() {\n        return new Ellipse(set([], this.pos), set([], this.r), copyAttribs(this));\n    }\n    toHiccup() {\n        return [\"ellipse\", this.attribs, this.pos, this.r];\n    }\n}\n\nclass Group {\n    constructor(attribs, children = []) {\n        this.attribs = attribs;\n        this.children = children;\n    }\n    get type() {\n        return \"group\";\n    }\n    *[Symbol.iterator]() {\n        yield* this.children;\n    }\n    copy() {\n        return this.copyTransformed((c) => c.copy());\n    }\n    copyTransformed(fn) {\n        return new Group(copyAttribs(this), this.children.map(fn));\n    }\n    equiv(o) {\n        return o instanceof Group && equiv(this.children, o.children);\n    }\n    toHiccup() {\n        return [\"g\", this.attribs, ...this.children.map((x) => x.toHiccup())];\n    }\n}\n\nclass Line extends APC {\n    get type() {\n        return \"line\";\n    }\n    copy() {\n        return copyShape(Line, this);\n    }\n    toHiccup() {\n        return [\"line\", this.attribs, this.points[0], this.points[1]];\n    }\n    toHiccupPathSegments() {\n        const [a, b] = this.points;\n        return [\n            a[0] === b[0]\n                ? [\"V\", b[1]]\n                : a[1] === b[1]\n                    ? [\"H\", b[0]]\n                    : [\"L\", b],\n        ];\n    }\n}\n\nclass Path {\n    constructor(segments = [], attribs) {\n        this.segments = segments;\n        this.attribs = attribs;\n        this.closed = false;\n    }\n    get type() {\n        return \"path\";\n    }\n    *[Symbol.iterator]() {\n        yield* this.segments;\n    }\n    copy() {\n        const p = new Path(this.segments.map((s) => {\n            const d = { type: s.type };\n            s.point && (d.point = copy(s.point));\n            s.geo && (d.geo = s.geo.copy());\n            return d;\n        }), copyAttribs(this));\n        p.closed = this.closed;\n        return p;\n    }\n    equiv(o) {\n        return o instanceof Path && equiv(this.segments, o.segments);\n    }\n    add(s) {\n        if (this.closed)\n            illegalState(\"path already closed\");\n        this.segments.push(s);\n    }\n    toHiccup() {\n        let dest = [];\n        const segments = this.segments;\n        const n = segments.length;\n        if (n > 1) {\n            for (let i = 0; i < n; i++) {\n                const s = segments[i];\n                if (s.geo) {\n                    dest = dest.concat(s.geo.toHiccupPathSegments());\n                }\n                else if (s.point) {\n                    dest.push([\"M\", s.point]);\n                }\n            }\n            if (this.closed) {\n                dest.push([\"Z\"]);\n            }\n        }\n        return [\"path\", this.attribs || {}, dest];\n    }\n}\n\nclass Plane {\n    constructor(normal = [0, 1, 0], w = 0, attribs) {\n        this.normal = normal;\n        this.w = w;\n        this.attribs = attribs;\n    }\n    get type() {\n        return \"plane\";\n    }\n    copy() {\n        return new Plane(set([], this.normal), this.w, copyAttribs(this));\n    }\n    toHiccup() {\n        return [\"plane\", this.attribs, this.normal, this.w];\n    }\n}\n\nclass Points extends APC {\n    get type() {\n        return \"points\";\n    }\n    copy() {\n        return copyShape(Points, this);\n    }\n    toHiccup() {\n        return [\"points\", this.attribs, this.points];\n    }\n}\nclass Points3 extends APC {\n    get type() {\n        return \"points3\";\n    }\n    copy() {\n        return copyShape(Points3, this);\n    }\n    toHiccup() {\n        return [\"points3\", this.attribs, this.points];\n    }\n}\n\nclass Polygon extends APC {\n    get type() {\n        return \"poly\";\n    }\n    copy() {\n        return copyShape(Polygon, this);\n    }\n    toHiccup() {\n        return [\"polygon\", this.attribs, this.points];\n    }\n}\n\nclass Polyline extends APC {\n    get type() {\n        return \"polyline\";\n    }\n    copy() {\n        return copyShape(Polyline, this);\n    }\n    toHiccup() {\n        return [\"polyline\", Object.assign(Object.assign({}, this.attribs), { fill: \"none\" }), this.points];\n    }\n    toHiccupPathSegments() {\n        const res = [];\n        for (let pts = this.points, n = pts.length, i = 1; i < n; i++) {\n            res.push([\"L\", pts[i]]);\n        }\n        return res;\n    }\n}\n\nclass Quad extends APC {\n    get type() {\n        return \"quad\";\n    }\n    copy() {\n        return copyShape(Quad, this);\n    }\n    toHiccup() {\n        return [\"polygon\", this.attribs, this.points];\n    }\n}\n\nclass Quad3 extends APC {\n    get type() {\n        return \"quad3\";\n    }\n    copy() {\n        return copyShape(Quad3, this);\n    }\n    toHiccup() {\n        return [\"polygon\", this.attribs, this.points];\n    }\n}\n\nclass Quadratic extends APC {\n    get type() {\n        return \"quadratic\";\n    }\n    copy() {\n        return copyShape(Quadratic, this);\n    }\n    toHiccup() {\n        return [\n            \"path\",\n            this.attribs,\n            [[\"M\", this.points[0]], ...this.toHiccupPathSegments()],\n        ];\n    }\n    toHiccupPathSegments() {\n        const pts = this.points;\n        return [[\"Q\", pts[1], pts[2]]];\n    }\n}\n\nclass Ray {\n    constructor(pos, dir, attribs) {\n        this.pos = pos;\n        this.dir = dir;\n        this.attribs = attribs;\n    }\n    get type() {\n        return \"ray\";\n    }\n    copy() {\n        return new Ray(set([], this.pos), set([], this.dir), copyAttribs(this));\n    }\n    toHiccup() {\n        return [\n            \"line\",\n            this.attribs,\n            this.pos,\n            maddN2([], this.dir, 1e6, this.pos),\n        ];\n    }\n}\n\nclass Rect {\n    constructor(pos = [0, 0], size = 1, attribs) {\n        this.pos = pos;\n        this.attribs = attribs;\n        this.size = isNumber(size) ? [size, size] : size;\n    }\n    get type() {\n        return \"rect\";\n    }\n    copy() {\n        return new Rect(set([], this.pos), set([], this.size), copyAttribs(this));\n    }\n    max() {\n        return add2([], this.pos, this.size);\n    }\n    toHiccup() {\n        return [\"rect\", this.attribs, this.pos, this.size[0], this.size[1]];\n    }\n}\n\nclass Sphere {\n    constructor(pos = [0, 0, 0], r = 1, attribs) {\n        this.pos = pos;\n        this.r = r;\n        this.attribs = attribs;\n    }\n    get type() {\n        return \"sphere\";\n    }\n    copy() {\n        return new Sphere(set3([], this.pos), this.r, copyAttribs(this));\n    }\n    toHiccup() {\n        return [\"sphere\", this.attribs, this.pos, this.r];\n    }\n}\n\n/**\n * Basic stub for text elements. Currently, only a minimal set of geometry\n * operations are implemented for this type, however this type implements\n * {@link @this.ng/api#IToHiccup} and so is useful as wrapper for inclusion of\n * text elements in {@link Group}s with other shape types.\n */\nclass Text {\n    constructor(pos, body, attribs) {\n        this.pos = pos;\n        this.body = body;\n        this.attribs = attribs;\n    }\n    get type() {\n        return \"text\";\n    }\n    copy() {\n        return new Text(set([], this.pos), this.body, copyAttribs(this));\n    }\n    toHiccup() {\n        return [\"text\", this.attribs, this.pos, this.body];\n    }\n}\n\nclass Triangle extends APC {\n    get type() {\n        return \"tri\";\n    }\n    copy() {\n        return copyShape(Triangle, this);\n    }\n    toHiccup() {\n        return [\"polygon\", this.attribs, this.points];\n    }\n}\n\n/**\n * Takes an array of arguments, checks if last element is a plain object\n * and if so, removes it from array and returns it. Else returns\n * `undefined`.\n *\n * @param args -\n *\n * @internal\n */\nconst argAttribs = (args) => isPlainObject(peek(args)) ? args.pop() : undefined;\n/**\n * Args parser for functions expecting up to 2 vector args and optional\n * attribs object. Returns 3-tuple of re-structured args.\n *\n * @param args -\n *\n * @internal\n */\nconst argsVV = (args) => {\n    const attr = argAttribs(args);\n    return args.length\n        ? args.length === 2\n            ? [args[0], args[1], attr]\n            : [undefined, args[0], attr]\n        : [undefined, undefined, attr];\n};\n/**\n * Args parser for functions expecting a vector, numeric and/or optional\n * attribs object. Returns 3-tuple of re-structured args.\n *\n * @param args -\n *\n * @internal\n */\nconst argsVN = (args) => {\n    const attr = argAttribs(args);\n    return args.length\n        ? args.length === 2\n            ? [args[0], args[1], attr]\n            : isNumber(args[0])\n                ? [undefined, args[0], attr]\n                : [args[0], undefined, attr]\n        : [undefined, undefined, attr];\n};\n\nfunction aabb(...args) {\n    return new AABB(...argsVV(args));\n}\nconst aabbFromMinMax = (min, max, attribs) => new AABB(min, sub3([], max, min), attribs);\n/**\n * Returns the intersection AABB of given inputs or `undefined` if they\n * are non-overlapping.\n *\n * @param a\n * @param b\n */\nconst intersectionAABB = (a, b) => {\n    const p = max3([], a.pos, b.pos);\n    const q = min3(null, add3([], a.pos, a.size), add3([], b.pos, b.size));\n    const size = max3(null, sub3(null, q, p), ZERO3);\n    return size[0] > 0 && size[1] > 0 && size[2] > 0\n        ? new AABB(p, size)\n        : undefined;\n};\nfunction inscribedAABB(...args) {\n    let pos, r;\n    if (args.length === 1) {\n        const c = args[0];\n        pos = c.pos;\n        r = c.r;\n    }\n    else {\n        [pos, r] = args;\n    }\n    r *= SQRT2_2;\n    return aabb(subN3([], pos, r), r * 2);\n}\n\nconst arc = (pos, r, axis, start, end, xl = false, clockwise = false) => new Arc(pos, isNumber(r) ? [r, r] : r, axis, start, end, xl, clockwise);\nconst arcFrom2Points = (a, b, radii, axis = 0, xl = false, cw = false, attribs) => {\n    const res = fromEndPoints(a, b, radii, axis, xl, cw);\n    return res\n        ? new Arc(res.center, res.r, res.axis, res.start, res.end, res.xl, res.cw, attribs)\n        : undefined;\n};\n\n/**\n * Interprets given points as closed 2D polygon and computes its signed\n * area. If result is negative, the polygon is clockwise.\n *\n * @param pts - points\n */\nconst polyArea2 = (pts) => {\n    const n = pts.length - 1;\n    if (n < 2)\n        return 0;\n    let res = 0;\n    let a = pts[n];\n    let b = pts[0];\n    for (let i = 0; i <= n; a = b, b = pts[++i]) {\n        res += cross2(a, b);\n    }\n    return res / 2;\n};\n\n/**\n * Computes the nD bounds of given vectors. `vmin` should be initialized\n * to `+` and `vmax` to `-` (e.g. use copies of `MIN*` / `MAX*`\n * constants defined in thi.ng/vectors).\n *\n * @example\n * ```ts\n * points = [[-1,-2], [5,-3], [0,4]];\n *\n * bounds(points, [...MAX2], [...MIN2])\n * // [[-1,-3],[5,4]]\n * ```\n *\n * Returns 2-tuple of modified `[vmin, vmax]`.\n *\n * @param pts - point\n * @param vmin - min result (pre-initialized to `+`)\n * @param vmax - max result (pre-initialized to `-`)\n */\nconst bounds$1 = (pts, vmin, vmax) => {\n    for (let i = pts.length; --i >= 0;) {\n        const p = pts[i];\n        min(null, vmin, p);\n        max(null, vmax, p);\n    }\n    return [vmin, vmax];\n};\n\nconst centerOfWeight2 = (pts, out = []) => {\n    const n = pts.length - 1;\n    let area = 0;\n    let x = 0;\n    let y = 0;\n    let a = pts[n];\n    let b = pts[0];\n    for (let i = 0; i <= n; a = b, b = pts[++i]) {\n        const z = cross2(a, b);\n        area += z;\n        x += (a[0] + b[0]) * z;\n        y += (a[1] + b[1]) * z;\n    }\n    area = 1 / (area * 3);\n    out[0] = x * area;\n    out[1] = y * area;\n    return out;\n};\n\nconst equilateralTriangle2 = (a, b) => {\n    const dir = sub2([], b, a);\n    const c = normalize$1(null, perpendicularCCW([], dir), mag(dir) * Math.sin(THIRD_PI));\n    return [a, b, maddN2(null, dir, 0.5, c)];\n};\n\nconst perimeter = (pts, num = pts.length, closed = false) => {\n    if (num < 2)\n        return 0;\n    let res = 0;\n    let p = pts[0];\n    let q = pts[1];\n    for (let i = 1; i < num; p = q, q = pts[++i]) {\n        res += dist(p, q);\n    }\n    return closed ? res + dist(p, pts[0]) : res;\n};\n\nfunction circle(...args) {\n    return new Circle(...argsVN(args));\n}\nconst circleFrom2Points = (a, b, attribs) => new Circle(mixN2([], a, b, 0.5), dist(a, b) / 2, attribs);\nconst circleFrom3Points = (a, b, c, attribs) => {\n    const o = circumCenter2(a, b, c);\n    return o ? new Circle(o, dist(a, o), attribs) : undefined;\n};\n\n/**\n * Converts line segment `a` -> `b` into a cubic curve, which when\n * sampled yields uniformly spaced points. The inner control points are\n * located at 1/3 and 2/3 respectively.\n *\n * @param a - line endpoint\n * @param b - line endpoint\n */\nconst cubicFromLine = (a, b) => [\n    set([], a),\n    mixN([], a, b, 1 / 3),\n    mixN([], b, a, 1 / 3),\n    set([], b),\n];\n\n/**\n * Converts elliptic arc into a 1-4 cubic curve segments, depending on\n * arc's angle range.\n *\n * Partially based on:\n * {@link https://github.com/chromium/chromium/blob/develop/third_party/blink/renderer/core/svg/svg_path_parser.cc#L253}\n *\n * @param pos - ellipse center\n * @param r - ellipse radii\n * @param axis - rotation angle (radians)\n * @param start - start angle (radians)\n * @param end - end angle (radians)\n */\nconst cubicFromArc = (pos, r, axis, start, end) => {\n    const p = pointAtTheta(pos, r, axis, start);\n    const q = pointAtTheta(pos, r, axis, end);\n    const delta = end - start;\n    const [rx, ry] = r;\n    const [s, c] = sincos(axis);\n    const dx = (c * (p[0] - q[0])) / 2 + (s * (p[1] - q[1])) / 2;\n    const dy = (-s * (p[0] - q[0])) / 2 + (c * (p[1] - q[1])) / 2;\n    if ((Math.abs(delta) < PI && dx === 0 && dy === 0) || magSq2(r) < EPS) {\n        return [cubicFromLine(p, q)];\n    }\n    const mapP = (x, y) => {\n        x *= rx;\n        y *= ry;\n        return [c * x - s * y + pos[0], s * x + c * y + pos[1]];\n    };\n    const res = [];\n    const n = Math.ceil(roundEps(Math.abs(delta) / HALF_PI, 1e-3));\n    const d = delta / n;\n    const t = (8 / 6) * Math.tan(0.25 * d);\n    if (!isFinite(t)) {\n        return [cubicFromLine(p, q)];\n    }\n    for (let i = n, theta = start, sc = sincos(theta); i > 0; i--, theta += d) {\n        const [s1, c1] = sc;\n        const [s2, c2] = (sc = sincos(theta + d));\n        res.push([\n            mapP(c1, s1),\n            mapP(c1 - s1 * t, s1 + c1 * t),\n            mapP(c2 + s2 * t, s2 - c2 * t),\n            mapP(c2, s2),\n        ]);\n    }\n    return res;\n};\n\n/**\n * Computes cubic spline bounds for a single vector component.\n *\n * Based on:\n * {@link http://www.iquilezles.org/www/articles/bezierbbox/bezierbbox.htm}\n *\n * @param min - min accumulator\n * @param max - max accumulator\n * @param i - vector component\n * @param pa - control point 1\n * @param pb - control point 2\n * @param pc - control point 3\n * @param pd - control point 4\n */\nconst axisBounds = (min, max, i, pa, pb, pc, pd) => {\n    min[i] = Math.min(pa, pd);\n    max[i] = Math.max(pa, pd);\n    const k0 = -pa + pb;\n    const k1 = pa - 2 * pb + pc;\n    const k2 = -pa + 3 * pb - 3 * pc + pd;\n    let h = k1 * k1 - k0 * k2;\n    if (h > 0) {\n        h = Math.sqrt(h);\n        const update = (t) => {\n            if (t > 0 && t < 1) {\n                const q = mixCubic(pa, pb, pc, pd, t);\n                min[i] = Math.min(min[i], q);\n                max[i] = Math.max(max[i], q);\n            }\n        };\n        update(k0 / (-k1 - h));\n        update(k0 / (-k1 + h));\n    }\n};\nconst cubicBounds = (a, b, c, d) => {\n    const min = [];\n    const max = [];\n    for (let i = a.length; --i >= 0;) {\n        axisBounds(min, max, i, a[i], b[i], c[i], d[i]);\n    }\n    return [min, max];\n};\n\n/**\n * Performs recursive search for closest point to `p` on cubic curve\n * defined by control points `a`,`b`,`c`,`d`. The `res` and `recur`\n * params are used to control the recursion behavior. If `eps` is given,\n * the search is terminated as soon as a point with a shorter *squared*\n * distance than `eps` is found.\n *\n * {@link @thi.ng/math#minError}\n *\n * @param p - query point\n * @param a - control point 1\n * @param b - control point 2\n * @param c - control point 3\n * @param d - control point 4\n * @param res - search steps per iteration\n * @param iter - iterations\n * @param eps - epsilon value\n */\nconst closestPointCubic = (p, a, b, c, d, out = [], res, iter, eps) => {\n    const fn = (t) => mixCubic$1(out, a, b, c, d, t);\n    return fn(minError(fn, distSq, p, res, iter, 0, 1, eps));\n};\n\nconst buildSegments = (tangents, t, uniform) => {\n    const res = [];\n    for (let i = 0, num = tangents.length - 1; i < num; i++) {\n        const [a, na] = tangents[i];\n        const [b, nb] = tangents[i + 1];\n        const d = uniform ? t : t * dist(a, b);\n        res.push([a, maddN([], na, d, a), maddN([], nb, -d, b), b]);\n    }\n    return res;\n};\nconst closedCubicFromBreakPoints = (points, t = 1 / 3, uniform = false) => {\n    const tangents = [];\n    for (let num = points.length, i = num - 1, j = 0; j < num; i = j, j++) {\n        const a = points[i];\n        const b = points[j];\n        const c = points[(j + 1) % num];\n        const n = mulN(null, perpendicularCW(null, cornerBisector([], a, b, c)), corner2(a, b, c));\n        tangents.push([set([], b), n]);\n    }\n    tangents.push(tangents[0]);\n    return buildSegments(tangents, t, uniform);\n};\nconst openCubicFromBreakPoints = (points, t = 1 / 3, uniform = false) => {\n    const tangents = [\n        [points[0], direction([], points[0], points[1])],\n    ];\n    const num = points.length - 1;\n    for (let i = 1; i < num; i++) {\n        const a = points[i - 1];\n        const b = points[i];\n        const c = points[i + 1];\n        const n = mulN(null, perpendicularCW(null, cornerBisector([], a, b, c)), corner2(a, b, c));\n        tangents.push([set([], b), n]);\n    }\n    tangents.push([points[num], direction([], points[num - 1], points[num])]);\n    return buildSegments(tangents, t, uniform);\n};\n\nconst buildUniform = (segments, t) => {\n    const res = [];\n    for (let i = 0, n = segments.length - 2; i < n; i += 2) {\n        const a = segments[i];\n        const b = segments[i + 1];\n        const c = segments[i + 2];\n        res.push([\n            a,\n            add(null, direction([], a, b, t), a),\n            add(null, direction([], c, b, t), c),\n            c,\n        ]);\n    }\n    return res;\n};\nconst buildNonUniform = (segments, t) => {\n    const res = [];\n    for (let i = 0, n = segments.length - 2; i < n; i += 2) {\n        const a = segments[i];\n        const b = segments[i + 1];\n        const c = segments[i + 2];\n        res.push([a, mixN([], a, b, t), mixN([], c, b, t), c]);\n    }\n    return res;\n};\nconst closedCubicFromControlPoints = (points, t = 1, uniform = false) => {\n    const segments = [];\n    for (let i = 0, num = points.length; i < num; i++) {\n        const q = points[(i + 1) % num];\n        segments.push(addmN([], points[i], q, 0.5), set([], q));\n    }\n    segments.push(segments[0]);\n    return uniform ? buildUniform(segments, t) : buildNonUniform(segments, t);\n};\nconst openCubicFromControlPoints = (points, t = 1, uniform = false) => {\n    const segments = [set([], points[0]), set([], points[0])];\n    const num = points.length - 1;\n    for (let i = 0; i < num; i++) {\n        const q = points[i + 1];\n        segments.push(addmN([], points[i], q, 0.5), set([], q));\n    }\n    segments.push(set([], points[num]));\n    return uniform ? buildUniform(segments, t) : buildNonUniform(segments, t);\n};\n\nconst cubicFromQuadratic = (a, b, c) => [\n    set([], a),\n    mixN([], a, b, 2 / 3),\n    mixN([], c, b, 2 / 3),\n    set([], c),\n];\n\nconst __sample = (sample) => function $(pts, opts) {\n    if (isPlainObject(opts) && opts.dist !== undefined) {\n        return new Sampler($(pts, opts.num || DEFAULT_SAMPLES)).sampleUniform(opts.dist, opts.last !== false);\n    }\n    opts = isNumber(opts)\n        ? {\n            num: opts,\n            last: true,\n        }\n        : Object.assign({ num: DEFAULT_SAMPLES }, opts);\n    const res = [];\n    sample(res, pts, opts.num);\n    opts.last && res.push(set([], pts[pts.length - 1]));\n    return res;\n};\n\nconst sampleCubic = __sample((res, [a, b, c, d], num) => {\n    const delta = 1 / num;\n    for (let t = 0; t < num; t++) {\n        res.push(mixCubic$1([], a, b, c, d, t * delta));\n    }\n});\n\nconst cubicSplitAt = (a, b, c, d, t) => {\n    if (t <= 0 || t >= 1) {\n        const p = t <= 0 ? a : d;\n        const c1 = [set([], p), set([], p), set([], p), set([], p)];\n        const c2 = [set([], a), set([], b), set([], c), set([], d)];\n        return t <= 0 ? [c1, c2] : [c2, c1];\n    }\n    const ab = mixN([], a, b, t);\n    const bc = mixN([], b, c, t);\n    const cd = mixN([], c, d, t);\n    const abc = mixN([], ab, bc, t);\n    const bcd = mixN([], bc, cd, t);\n    const p = mixN([], abc, bcd, t);\n    return [\n        [set([], a), ab, abc, set([], p)],\n        [p, bcd, cd, set([], d)],\n    ];\n};\nconst splitCubicNearPoint = (p, a, b, c, d, res, iter) => cubicSplitAt(a, b, c, d, minError((t) => mixCubic$1([], a, b, c, d, t), distSq, p, res, iter));\n\nconst cubicTangentAt = (out, a, b, c, d, t, len = 1) => {\n    const s = 1 - t;\n    const ss = s * s;\n    const tt = t * t;\n    const ts2 = 2 * t * s;\n    return normalize$1(out, addW4(out, a, b, c, d, -3 * ss, 3 * (ss - ts2), 3 * (ts2 - tt), 3 * tt), len);\n};\n\nconst solveQuadratic = (a, b, c) => {\n    const t = clamp01((a - b) / (a - 2.0 * b + c));\n    const s = 1 - t;\n    return s * s * a + 2.0 * s * t * b + t * t * c;\n};\nconst inBounds = (p, min, max) => {\n    for (let i = p.length; --i >= 0;) {\n        if (!inRange(p[i], min[i], max[i]))\n            return false;\n    }\n    return true;\n};\nconst quadraticBounds = (a, b, c) => {\n    const mi = min([], a, c);\n    const ma = max([], a, c);\n    if (!inBounds(b, mi, ma)) {\n        const q = [];\n        for (let i = a.length; --i >= 0;) {\n            q[i] = solveQuadratic(a[i], b[i], c[i]);\n        }\n        min(null, mi, q);\n        max(null, ma, q);\n    }\n    return [mi, ma];\n};\n\n/**\n * Performs recursive search for closest point to `p` on quadratic curve\n * defined by control points `a`,`b`,`c`. The `res` and `recur` params\n * are used to control the recursion behavior. If `eps` is given, the\n * search is terminated as soon as a point with a shorter *squared*\n * distance than `eps` is found.\n *\n * {@link @thi.ng/math#minError}\n *\n * @param p - query point\n * @param a - control point 1\n * @param b - control point 2\n * @param c - control point 3\n * @param res - search steps per iteration\n * @param iter - iterations\n * @param eps - epsilon value\n */\nconst closestPointQuadratic = (p, a, b, c, out = [], res, iter, eps) => {\n    const fn = (t) => mixQuadratic(out, a, b, c, t);\n    return fn(minError(fn, distSq, p, res, iter, 0, 1, eps));\n};\n\nconst quadraticFromLine = (a, b) => [\n    set([], a),\n    addmN([], a, b, 0.5),\n    set([], b),\n];\n\nconst sampleQuadratic = __sample((res, [a, b, c], num) => {\n    const delta = 1 / num;\n    for (let t = 0; t < num; t++) {\n        res.push(mixQuadratic([], a, b, c, t * delta));\n    }\n});\n\nconst quadraticSplitAt = (a, b, c, t) => {\n    if (t <= 0 || t >= 1) {\n        const p = t <= 0 ? a : c;\n        const c1 = [set([], p), set([], p), set([], p)];\n        const c2 = [set([], a), set([], b), set([], c)];\n        return t <= 0 ? [c1, c2] : [c2, c1];\n    }\n    const ab = mixN([], a, b, t);\n    const bc = mixN([], b, c, t);\n    const p = mixN([], ab, bc, t);\n    return [\n        [set([], a), ab, p],\n        [p, bc, set([], c)],\n    ];\n};\nconst quadraticSplitNearPoint = (p, a, b, c, res, iter) => quadraticSplitAt(a, b, c, minError((t) => mixQuadratic([], a, b, c, t), distSq, p, res, iter));\n\nconst quadraticTangentAt = (out, a, b, c, t, len = 1) => normalize$1(out, addW2(out, sub(out, b, a), sub([], c, b), 2 * (1 - t), 2 * t), len);\n\nconst pclike = (ctor, args) => {\n    const attr = argAttribs(args);\n    return new ctor(args.length === 1 ? args[0] : args, attr);\n};\n\nfunction cubic(...args) {\n    return pclike(Cubic, args);\n}\nconst cubicFromArc$1 = (arc) => cubicFromArc(arc.pos, arc.r, arc.axis, arc.start, arc.end).map((c) => new Cubic(c, copyAttribs(arc)));\nconst cubicFromLine$1 = (a, b, attribs) => new Cubic(cubicFromLine(a, b), attribs);\nconst cubicFromQuadratic$1 = (a, b, c, attribs) => new Cubic(cubicFromQuadratic(a, b, c), attribs);\n\nfunction ellipse(...args) {\n    return new Ellipse(...argsVV(args));\n}\n\nconst group = (attribs = {}, children) => new Group(attribs, children);\n\nconst NONE = Object.freeze({\n    type: IntersectionType.NONE,\n});\n\nconst intersectCircleCircle = (a, b, ar, br) => {\n    const delta = sub([], b, a);\n    const d = mag(delta);\n    if (eqDelta$1(d, 0)) {\n        return { type: IntersectionType.COINCIDENT };\n    }\n    if (d <= ar + br && d >= Math.abs(ar - br)) {\n        ar *= ar;\n        const alpha = (ar - br * br + d * d) / (2 * d);\n        const h = Math.sqrt(ar - alpha * alpha);\n        const p = maddN([], delta, alpha / d, a);\n        const t = mulN(null, perpendicularCCW(null, delta), h / d);\n        return {\n            type: IntersectionType.INTERSECT,\n            isec: [add([], p, t), sub([], p, t)],\n        };\n    }\n    return NONE;\n};\n\nconst intersectRayLine = (rpos, dir, a, b, minD = 0, maxD = Infinity) => {\n    const bax = b[0] - a[0];\n    const bay = b[1] - a[1];\n    const d = dir[0] * bay - dir[1] * bax;\n    if (eqDelta$1(d, 0)) {\n        return NONE;\n    }\n    const arx = a[0] - rpos[0];\n    const ary = a[1] - rpos[1];\n    const t = (bay * arx - bax * ary) / d;\n    const s = (dir[1] * arx - dir[0] * ary) / d;\n    return t >= minD && t <= maxD && s >= 0 && s <= 1\n        ? {\n            type: IntersectionType.INTERSECT,\n            isec: maddN([], dir, t, rpos),\n            alpha: t,\n        }\n        : NONE;\n};\n\nconst startPoints = (pts, closed) => closed ? [pts[pts.length - 1], pts[0]] : [pts[0], pts[1]];\nconst intersectRayPolyline = (rpos, dir, pts, closed = false, minD = 0, maxD = Infinity) => {\n    const n = pts.length - 1;\n    let alpha = maxD;\n    let cross = 0;\n    let [i, j] = startPoints(pts, closed);\n    for (let k = 0; k <= n; i = j, j = pts[++k]) {\n        const d = intersectRayLine(rpos, dir, i, j, minD, maxD).alpha;\n        if (d !== undefined) {\n            cross++;\n            if (d < alpha)\n                alpha = d;\n        }\n    }\n    return cross > 0\n        ? {\n            type: IntersectionType.INTERSECT,\n            isec: maddN2([], dir, alpha, rpos),\n            inside: !(cross & 1),\n            alpha,\n        }\n        : NONE;\n};\nconst intersectRayPolylineAll = (rpos, dir, pts, closed = false, minD = 0, maxD = Infinity) => {\n    const n = pts.length - 1;\n    let [i, j] = startPoints(pts, closed);\n    const res = [];\n    for (let k = 0; k <= n; i = j, j = pts[++k]) {\n        const d = intersectRayLine(rpos, dir, i, j, minD, maxD).alpha;\n        if (d !== undefined) {\n            res.push([d, maddN2([], dir, d, rpos)]);\n        }\n    }\n    return res.length\n        ? {\n            type: IntersectionType.INTERSECT,\n            isec: res.sort((a, b) => a[0] - b[0]).map((x) => x[1]),\n        }\n        : NONE;\n};\n\nconst intersectLinePolylineAll = (a, b, pts, closed = false) => {\n    const dir = sub([], b, a);\n    const maxD = mag(dir);\n    return intersectRayPolylineAll(a, normalize$1(null, dir), pts, closed, 0, maxD);\n};\n\nconst intersectPlanePlane = (na, wa, nb, wb) => {\n    const dn = dot3(na, nb);\n    if (eqDelta$1(dn, 1)) {\n        return eqDelta$1(wa, wb) ? { type: IntersectionType.COINCIDENT } : NONE;\n    }\n    const det = 1 / (1 - dn * dn);\n    const da = (wa - wb * dn) * det;\n    const db = (wb - wa * dn) * det;\n    return {\n        type: IntersectionType.INTERSECT,\n        isec: [\n            add3(null, mulN3([], na, da), mulN3([], nb, db)),\n            cross3([], na, nb),\n        ],\n    };\n};\n\nconst intersectRayCircle = (rpos, dir, spos, r) => {\n    const delta = sub([], spos, rpos);\n    const w = dot(delta, dir);\n    let d = r * r + w * w - magSq(delta);\n    if (d < 0)\n        return NONE;\n    d = Math.sqrt(d);\n    const a = w + d;\n    const b = w - d;\n    const isec = a >= 0\n        ? b >= 0\n            ? a > b\n                ? [maddN(delta, dir, b, rpos), maddN([], dir, a, rpos)]\n                : [maddN(delta, dir, a, rpos), maddN([], dir, b, rpos)]\n            : [maddN(delta, dir, a, rpos)]\n        : b >= 0\n            ? [maddN(delta, dir, b, rpos)]\n            : undefined;\n    return isec ? { type: IntersectionType.INTERSECT, isec } : NONE;\n};\n\nconst intersectRayPlane = (rpos, dir, normal, w, eps = EPS) => {\n    const d = dot(normal, dir);\n    const cp = sign(dot(normal, rpos) - w, eps);\n    if ((d > eps && cp < 0) || (d < -eps && cp > 0)) {\n        const isec = sub(null, mulN([], normal, w), rpos);\n        const alpha = dot(normal, isec) / d;\n        return {\n            type: IntersectionType.INTERSECT,\n            isec: maddN(isec, dir, alpha, rpos),\n            alpha,\n        };\n    }\n    return cp === 0\n        ? {\n            type: IntersectionType.COINCIDENT,\n            isec: copy(rpos),\n        }\n        : NONE;\n};\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n/**\n * Based on:\n * {@link https://tavianator.com/fast-branchless-raybounding-box-intersections/}\n *\n * @param rpos - ray origin\n * @param dir - ray dir\n * @param bmin - rect min\n * @param bmax - rect max\n */\nconst rayRect = (rpos, dir, bmin, bmax) => {\n    let p = rpos[0];\n    let d = 1 / dir[0];\n    let t1 = (bmin[0] - p) * d;\n    let t2 = (bmax[0] - p) * d;\n    let tmin = min$1(t1, t2);\n    let tmax = max$1(t1, t2);\n    p = rpos[1];\n    d = 1 / dir[1];\n    t1 = (bmin[1] - p) * d;\n    t2 = (bmax[1] - p) * d;\n    return [max$1(tmin, min$1(t1, t2)), min$1(tmax, max$1(t1, t2))];\n};\n/**\n * Like to {@link rayRect}, but for 3D (AABB).\n *\n * @param rpos - ray origin\n * @param dir - ray dir\n * @param bmin - box min\n * @param bmax - box max\n */\nconst rayBox = (rpos, dir, bmin, bmax) => {\n    let p = rpos[0];\n    let d = 1 / dir[0];\n    let t1 = (bmin[0] - p) * d;\n    let t2 = (bmax[0] - p) * d;\n    let tmin = min$1(t1, t2);\n    let tmax = max$1(t1, t2);\n    p = rpos[1];\n    d = 1 / dir[1];\n    t1 = (bmin[1] - p) * d;\n    t2 = (bmax[1] - p) * d;\n    tmin = max$1(tmin, min$1(t1, t2));\n    tmax = min$1(tmax, max$1(t1, t2));\n    p = rpos[2];\n    d = 1 / dir[2];\n    t1 = (bmin[2] - p) * d;\n    t2 = (bmax[2] - p) * d;\n    return [max$1(tmin, min$1(t1, t2)), min$1(tmax, max$1(t1, t2))];\n};\nconst intersectWith = (fn) => (rpos, dir, bmin, bmax) => {\n    const t = fn(rpos, dir, bmin, bmax);\n    const tmin = t[0];\n    const tmax = t[1];\n    const inside = tmin < 0;\n    return tmax > max$1(tmin, 0)\n        ? inside\n            ? {\n                type: IntersectionType.INTERSECT,\n                isec: [maddN([], dir, tmax, rpos)],\n                alpha: tmax,\n                inside,\n            }\n            : {\n                type: IntersectionType.INTERSECT,\n                isec: [\n                    maddN([], dir, tmin, rpos),\n                    maddN([], dir, tmax, rpos),\n                ],\n                alpha: tmin,\n                beta: tmax,\n            }\n        : NONE;\n};\nconst intersectRayRect = intersectWith(rayRect);\nconst intersectRayAABB = intersectWith(rayBox);\n\nconst testBoxSphere = vop(0);\n/**\n * Returns true if given 2D rect defined by `boxMinPos` and `boxSize`\n * intersects circle.\n *\n * @param boxMinPos\n * @param boxSize\n * @param circlePos\n * @param r\n */\nconst testRectCircle = testBoxSphere.add(2, (boxMinPos, boxSize, circlePos, r) => axis(circlePos[0], boxMinPos[0], boxSize[0]) +\n    axis(circlePos[1], boxMinPos[1], boxSize[1]) <=\n    r * r);\n/**\n * Same as {@link testRectCircle}, but for 3D AABB and sphere.\n *\n * @param boxMinPos\n * @param boxSize\n * @param spherePos\n * @param r\n */\nconst testAABBSphere = testBoxSphere.add(3, (boxMinPos, boxSize, spherePos, r) => axis(spherePos[0], boxMinPos[0], boxSize[0]) +\n    axis(spherePos[1], boxMinPos[1], boxSize[1]) +\n    axis(spherePos[2], boxMinPos[2], boxSize[2]) <=\n    r * r);\ntestBoxSphere.default((boxPos, boxSize, spherePos, r) => {\n    let sum = 0;\n    for (let i = boxPos.length; --i >= 0;) {\n        sum += axis(spherePos[i], boxPos[i], boxSize[i]);\n    }\n    return sum <= r * r;\n});\n/**\n * Like {@link testCenteredAABBSphere}, but for arbitrary dimensions w/\n * optimized execution for 2D & 3D cases.\n *\n * @param boxCenter\n * @param boxExtent\n * @param spherePos\n * @param r\n */\nconst testCenteredBoxSphere = vop(0);\n/**\n * Similar to {@link testRectCircle}, but for rects defined by centroid\n * and radius-like extent.\n *\n * @param rectPos\n * @param extent\n * @param circlePos\n * @param r\n */\nconst testCenteredRectCircle = testCenteredBoxSphere.add(2, (boxPos, { 0: w, 1: h }, circlePos, r) => axis(circlePos[0], boxPos[0] - w, w * 2) +\n    axis(circlePos[1], boxPos[1] - h, h * 2) <=\n    r * r);\n/**\n * Similar to {@link testAABBSphere}, but for AABBs defined by centroid\n * and radius-like extent.\n *\n * @param boxCenter\n * @param boxExtent\n * @param spherePos\n * @param r\n */\nconst testCenteredAABBSphere = testCenteredBoxSphere.add(3, (boxPos, { 0: w, 1: h, 2: d }, spherePos, r) => axis(spherePos[0], boxPos[0] - w, w * 2) +\n    axis(spherePos[1], boxPos[1] - h, h * 2) +\n    axis(spherePos[2], boxPos[2] - d, d * 2) <=\n    r * r);\ntestCenteredBoxSphere.default((boxPos, boxExtent, spherePos, r) => {\n    let sum = 0;\n    for (let i = boxPos.length; --i >= 0;) {\n        sum += axis(spherePos[i], boxPos[i] - boxExtent[i], boxExtent[i] * 2);\n    }\n    return sum <= r * r;\n});\nconst axis = (a, b, c) => (a < b ? a - b : a > b + c ? a - b - c : 0) ** 2;\n\nconst testRectRect = ([ax, ay], [aw, ah], [bx, by], [bw, bh]) => !(ax > bx + bw || bx > ax + aw || ay > by + bh || by > ay + ah);\n\nconst clipLineSegmentPoly = (a, b, pts) => {\n    const isecs = intersectLinePolylineAll(a, b, pts, true).isec;\n    const isAInside = pointInPolygon2(a, pts);\n    const isBInside = pointInPolygon2(b, pts);\n    if (!isecs) {\n        return isAInside && isBInside ? [[a, b]] : undefined;\n    }\n    isAInside && isecs.unshift(a);\n    isBInside && isecs.push(b);\n    return collectSegments(isecs);\n};\nconst collectSegments = (isecs) => {\n    const segments = [];\n    for (let i = 0, n = isecs.length - 1; i < n; i += 2) {\n        segments.push([isecs[i], isecs[i + 1]]);\n    }\n    return segments;\n};\n\nfunction line(...args) {\n    return pclike(Line, args);\n}\nconst clippedLine = (l, bounds) => {\n    const res = bounds instanceof Rect\n        ? liangBarsky2(l.points[0], l.points[1], bounds.pos, bounds.max())\n        : liangBarsky2(l.points[0], l.points[1], bounds[0], bounds[1]);\n    if (res) {\n        return new Line([res[0], res[1]], Object.assign({}, l.attribs));\n    }\n};\n\n/**\n * Unique symbol used for registering a default / fallback\n * implementation.\n */\nconst DEFAULT = Symbol();\nlet LOGGER = NULL_LOGGER;\n\nfunction defmulti(f, ancestors) {\n    const impls = {};\n    const rels = ancestors\n        ? makeRels(ancestors)\n        : {};\n    const fn = (...args) => {\n        const id = f(...args);\n        const g = impls[id] || findImpl(impls, rels, id) || impls[DEFAULT];\n        return g\n            ? g(...args)\n            : unsupported(`missing implementation for: \"${id.toString()}\"`);\n    };\n    fn.add = (id, g) => {\n        if (impls[id]) {\n            LOGGER.warn(`overwriting '${id.toString()}' impl`);\n        }\n        impls[id] = g;\n        return true;\n    };\n    fn.addAll = (_impls) => {\n        let ok = true;\n        for (let id in _impls) {\n            ok = fn.add(id, _impls[id]) && ok;\n        }\n        return ok;\n    };\n    fn.remove = (id) => {\n        if (!impls[id])\n            return false;\n        delete impls[id];\n        return true;\n    };\n    fn.callable = (...args) => {\n        const id = f(...args);\n        return !!(impls[id] ||\n            findImpl(impls, rels, id) ||\n            impls[DEFAULT]);\n    };\n    fn.isa = (id, parent) => {\n        let val = rels[id];\n        !val && (rels[id] = val = new Set());\n        val.add(parent);\n    };\n    fn.impls = () => {\n        const res = new Set(Object.keys(impls));\n        for (let id in rels) {\n            findImpl(impls, rels, id) && res.add(id);\n        }\n        impls[DEFAULT] && res.add(DEFAULT);\n        return res;\n    };\n    fn.rels = () => rels;\n    fn.parents = (id) => rels[id];\n    fn.ancestors = (id) => new Set(findAncestors([], rels, id));\n    fn.dependencies = function* () {\n        for (let a in rels) {\n            for (let b of rels[a])\n                yield [a, b];\n        }\n        for (let id in impls) {\n            !rels[id] && (yield [id, undefined]);\n        }\n    };\n    return fn;\n}\nconst findImpl = (impls, rels, id) => {\n    const parents = rels[id];\n    if (!parents)\n        return;\n    for (let p of parents) {\n        let impl = impls[p] || findImpl(impls, rels, p);\n        if (impl)\n            return impl;\n    }\n};\nconst findAncestors = (acc, rels, id) => {\n    const parents = rels[id];\n    if (parents) {\n        for (let p of parents) {\n            acc.push(p);\n            findAncestors(acc, rels, p);\n        }\n    }\n    return acc;\n};\nconst makeRels = (spec) => {\n    const rels = {};\n    for (let k in spec) {\n        const val = spec[k];\n        rels[k] = val instanceof Set ? val : new Set(val);\n    }\n    return rels;\n};\n\nconst dispatch = (x) => x.type;\nconst dispatch2 = (a, b) => a.type + \"-\" + b.type;\n\nconst vertices = defmulti(dispatch);\nvertices.addAll({\n    // e +----+ h\n    //   |\\   :\\\n    //   |f+----+ g\n    //   | |  : |\n    // a +-|--+d|\n    //    \\|   \\|\n    //   b +----+ c\n    //\n    aabb: ({ pos, size }) => {\n        const [px, py, pz] = pos;\n        const [qx, qy, qz] = add3([], pos, size);\n        return [\n            [px, py, pz],\n            [px, py, qz],\n            [qx, py, qz],\n            [qx, py, pz],\n            [px, qy, pz],\n            [px, qy, qz],\n            [qx, qy, qz],\n            [qx, qy, pz], // h\n        ];\n    },\n    arc: ($, opts) => sample($.pos, $.r, $.axis, $.start, $.end, opts),\n    circle: ($, opts = DEFAULT_SAMPLES) => {\n        const pos = $.pos;\n        const r = $.r;\n        let [num, last] = circleOpts(opts, r);\n        const delta = TAU / num;\n        last && num++;\n        const buf = new Array(num);\n        for (let i = 0; i < num; i++) {\n            buf[i] = cartesian2(null, [r, i * delta], pos);\n        }\n        return buf;\n    },\n    cubic: ($, opts) => sampleCubic($.points, opts),\n    ellipse: ($, opts = DEFAULT_SAMPLES) => {\n        const buf = [];\n        const pos = $.pos;\n        const r = $.r;\n        let [num, last] = circleOpts(opts, Math.max($.r[0], $.r[1]));\n        const delta = TAU / num;\n        last && num++;\n        for (let i = 0; i < num; i++) {\n            buf[i] = madd2([], cossin(i * delta), r, pos);\n        }\n        return buf;\n    },\n    group: ({ children }) => children.reduce((acc, $) => acc.concat(vertices($)), []),\n    path: ($, opts) => {\n        const _opts = isNumber(opts) ? { num: opts } : opts;\n        let verts = [];\n        for (let segs = $.segments, n = segs.length - 1, i = 0; i <= n; i++) {\n            const s = segs[i];\n            if (s.geo) {\n                verts = verts.concat(vertices(s.geo, Object.assign(Object.assign({}, _opts), { last: i === n && !$.closed })));\n            }\n        }\n        return verts;\n    },\n    points: ($) => $.points,\n    poly: ($, opts) => resample($.points, opts, true),\n    polyline: ($, opts) => resample($.points, opts),\n    quadratic: ($, opts) => sampleQuadratic($.points, opts),\n    rect: ($, opts) => {\n        const p = $.pos;\n        const q = add2([], p, $.size);\n        const verts = [set2([], p), [q[0], p[1]], q, [p[0], q[1]]];\n        return opts != null ? vertices(new Polygon(verts), opts) : verts;\n    },\n});\nvertices.isa(\"line\", \"polyline\");\nvertices.isa(\"points3\", \"points\");\nvertices.isa(\"quad\", \"poly\");\nvertices.isa(\"tri\", \"poly\");\n/**\n * Takes array of vectors or an `IShape`. If the latter, calls {@link vertices}\n * and return result, else returns original array.\n *\n * @param shape\n */\nconst ensureVertices = (shape) => isArray(shape) ? shape : vertices(shape);\nconst circleOpts = (opts, r) => isNumber(opts)\n    ? [opts, false]\n    : [\n        opts.theta\n            ? Math.floor(TAU / opts.theta)\n            : opts.dist\n                ? Math.floor(TAU / (opts.dist / r))\n                : opts.num || DEFAULT_SAMPLES,\n        opts.last === true,\n    ];\n\nconst asPolygon = defmulti(dispatch);\nasPolygon.addAll({\n    points: ($, opts) => new Polygon(vertices($, opts), copyAttribs($)),\n});\nasPolygon.isa(\"circle\", \"points\");\nasPolygon.isa(\"ellipse\", \"points\");\nasPolygon.isa(\"line\", \"points\");\nasPolygon.isa(\"path\", \"points\");\nasPolygon.isa(\"poly\", \"points\");\nasPolygon.isa(\"polyline\", \"points\");\nasPolygon.isa(\"quad\", \"points\");\nasPolygon.isa(\"rect\", \"points\");\nasPolygon.isa(\"tri\", \"points\");\n\nconst asCubic = defmulti(dispatch);\nasCubic.addAll({\n    arc: cubicFromArc$1,\n    circle: ($) => asCubic(arc($.pos, $.r, 0, 0, TAU, true, true)),\n    cubic: ($) => [$],\n    group: ($) => [...mapcat(asCubic, $.children)],\n    line: ({ attribs, points }) => [\n        cubicFromLine$1(points[0], points[1], Object.assign({}, attribs)),\n    ],\n    path: ($) => [\n        ...mapcat((s) => (s.geo ? asCubic(s.geo) : null), $.segments),\n    ],\n    poly: ($, opts = {}) => polyCubic($, opts, closedCubicFromBreakPoints, closedCubicFromControlPoints),\n    polyline: ($, opts = {}) => polyCubic($, opts, openCubicFromBreakPoints, openCubicFromControlPoints),\n    quadratic: ({ attribs, points }) => [\n        cubicFromQuadratic$1(points[0], points[1], points[2], Object.assign({}, attribs)),\n    ],\n    rect: ($, opts) => asCubic(asPolygon($), opts),\n});\nasCubic.isa(\"ellipse\", \"circle\");\nasCubic.isa(\"quad\", \"poly\");\nasCubic.isa(\"tri\", \"poly\");\n// prettier-ignore\nconst polyCubic = ($, opts, breakPoints, controlPoints) => {\n    opts = Object.assign({ breakPoints: false, scale: 1 / 3, uniform: false }, opts);\n    return (opts.breakPoints\n        ? breakPoints($.points, opts.scale, opts.uniform)\n        : controlPoints($.points, opts.scale, opts.uniform)).map((pts) => new Cubic(pts, copyAttribs($)));\n};\n\nclass PathBuilder {\n    constructor(attribs, opts = {}) {\n        this.attribs = attribs;\n        this.opts = opts;\n        this.paths = [];\n        this.attribs = attribs;\n        this.newPath();\n    }\n    *[Symbol.iterator]() {\n        yield* this.paths;\n    }\n    current() {\n        return this.curr;\n    }\n    newPath() {\n        this.curr = new Path([], this.attribs);\n        this.paths.push(this.curr);\n        this.currP = zeroes(2);\n        this.bezierP = zeroes(2);\n        this.startP = zeroes(2);\n    }\n    moveTo(p, relative = false) {\n        if (this.opts.autoSplit !== false && this.curr.segments.length > 0) {\n            this.curr = new Path([], this.attribs);\n            this.paths.push(this.curr);\n        }\n        p = this.updateCurrent(p, relative);\n        set2(this.startP, p);\n        set2(this.bezierP, p);\n        this.curr.add({\n            point: p,\n            type: \"m\",\n        });\n        return this;\n    }\n    lineTo(p, relative = false) {\n        this.curr.add({\n            geo: new Line([copy(this.currP), this.updateCurrent(p, relative)]),\n            type: \"l\",\n        });\n        set2(this.bezierP, this.currP);\n        return this;\n    }\n    hlineTo(x, relative = false) {\n        this.addHVLine(x, 0, relative);\n        return this;\n    }\n    vlineTo(y, relative = false) {\n        this.addHVLine(y, 1, relative);\n        return this;\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#Cubic_B%C3%A9zier_Curve\n    cubicTo(cp1, cp2, p, relative = false) {\n        this.addCubic(this.absPoint(cp1, relative), cp2, p, relative);\n        return this;\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#Quadratic_B%C3%A9zier_Curve\n    quadraticTo(cp, p, relative = false) {\n        this.addQuadratic(this.absPoint(cp, relative), p, relative);\n        return this;\n    }\n    cubicChainTo(cp2, p, relative = false) {\n        const prevMode = peek(this.curr.segments).type;\n        const c1 = copy(this.currP);\n        prevMode === \"c\" && add2(null, sub2([], c1, this.bezierP), c1);\n        this.addCubic(c1, cp2, p, relative);\n        return this;\n    }\n    quadraticChainTo(p, relative = false) {\n        const prevMode = peek(this.curr.segments).type;\n        const c1 = copy(this.currP);\n        prevMode === \"q\" && sub2(null, mulN2(null, c1, 2), this.bezierP);\n        this.addQuadratic(c1, p, relative);\n        return this;\n    }\n    arcTo(p, r, xaxis, xl, clockwise, relative = false) {\n        if (eqDelta$1(r[0], 0) || eqDelta$1(r[1], 0)) {\n            return this.lineTo(p, relative);\n        }\n        const prev = copy(this.currP);\n        this.curr.add({\n            geo: arcFrom2Points(prev, this.updateCurrent(p, relative), r, xaxis, xl, clockwise),\n            type: \"a\",\n        });\n        set2(this.bezierP, this.currP);\n        return this;\n    }\n    closePath() {\n        this.curr.add({\n            geo: new Line([copy(this.currP), copy(this.startP)]),\n            type: \"l\",\n        });\n        this.curr.closed = true;\n        return this;\n    }\n    updateCurrent(p, relative) {\n        p = copy(relative ? add2(null, this.currP, p) : set2(this.currP, p));\n        return p;\n    }\n    absPoint(p, relative) {\n        return relative ? add2(null, p, this.currP) : p;\n    }\n    addHVLine(p, i, relative) {\n        const prev = copy(this.currP);\n        this.currP[i] = relative ? this.currP[i] + p : p;\n        set2(this.bezierP, this.currP);\n        this.curr.add({\n            geo: new Line([prev, copy(this.currP)]),\n            type: \"l\",\n        });\n    }\n    addCubic(cp1, cp2, p, relative) {\n        cp2 = this.absPoint(cp2, relative);\n        set2(this.bezierP, cp2);\n        this.curr.add({\n            geo: new Cubic([\n                copy(this.currP),\n                cp1,\n                cp2,\n                this.updateCurrent(p, relative),\n            ]),\n            type: \"c\",\n        });\n    }\n    addQuadratic(cp, p, relative) {\n        set2(this.bezierP, cp);\n        this.curr.add({\n            geo: new Quadratic([\n                copy(this.currP),\n                cp,\n                this.updateCurrent(p, relative),\n            ]),\n            type: \"q\",\n        });\n    }\n}\nconst pathBuilder = (attribs, opts) => new PathBuilder(attribs, opts);\n\nconst path = (segments, attribs) => new Path(segments, attribs);\nconst pathFromCubics = (cubics, attribs) => {\n    const path = new Path([], attribs || cubics[0].attribs);\n    path.segments.push({ type: \"m\", point: cubics[0].points[0] });\n    for (let c of cubics) {\n        path.segments.push({ type: \"c\", geo: c });\n    }\n    return path;\n};\nconst normalizedPath = (path) => new Path([\n    ...mapcat((s) => s.geo\n        ? map((c) => ({ type: \"c\", geo: c }), asCubic(s.geo))\n        : [Object.assign({}, s)], path.segments),\n], path.attribs);\nconst roundedRect = (pos, size, r, attribs) => {\n    r = isNumber(r) ? [r, r] : r;\n    const [w, h] = maddN2([], r, -2, size);\n    return new PathBuilder(attribs)\n        .moveTo([pos[0] + r[0], pos[1]])\n        .hlineTo(w, true)\n        .arcTo(r, r, 0, false, true, true)\n        .vlineTo(h, true)\n        .arcTo([-r[0], r[1]], r, 0, false, true, true)\n        .hlineTo(-w, true)\n        .arcTo([-r[0], -r[1]], r, 0, false, true, true)\n        .vlineTo(-h, true)\n        .arcTo([r[0], -r[1]], r, 0, false, true, true)\n        .current();\n};\n\nconst CMD_RE = /[achlmqstvz]/i;\nconst WSC = Object.assign(Object.assign({}, WS), { \",\": true });\nconst pathFromSvg = (svg) => {\n    const b = new PathBuilder();\n    try {\n        let cmd = \"\";\n        for (let n = svg.length, i = 0; i < n;) {\n            i = skipWS(svg, i);\n            const c = svg.charAt(i);\n            if (CMD_RE.test(c)) {\n                cmd = c;\n                i++;\n            }\n            let p, pa, pb, t1, t2, t3;\n            switch (cmd.toLowerCase()) {\n                case \"m\":\n                    [p, i] = readPoint(svg, i);\n                    b.moveTo(p, cmd === \"m\");\n                    break;\n                case \"l\":\n                    [p, i] = readPoint(svg, i);\n                    b.lineTo(p, cmd === \"l\");\n                    break;\n                case \"h\":\n                    [p, i] = readFloat(svg, i);\n                    b.hlineTo(p, cmd === \"h\");\n                    break;\n                case \"v\":\n                    [p, i] = readFloat(svg, i);\n                    b.vlineTo(p, cmd === \"v\");\n                    break;\n                case \"q\":\n                    [pa, i] = readPoint(svg, i);\n                    [p, i] = readPoint(svg, i);\n                    b.quadraticTo(pa, p, cmd === \"q\");\n                    break;\n                case \"c\":\n                    [pa, i] = readPoint(svg, i);\n                    [pb, i] = readPoint(svg, i);\n                    [p, i] = readPoint(svg, i);\n                    b.cubicTo(pa, pb, p, cmd === \"c\");\n                    break;\n                case \"s\":\n                    [pa, i] = readPoint(svg, i);\n                    [p, i] = readPoint(svg, i);\n                    b.cubicChainTo(pa, p, cmd === \"s\");\n                    break;\n                case \"t\":\n                    [p, i] = readPoint(svg, i);\n                    b.quadraticChainTo(p, cmd === \"t\");\n                    break;\n                case \"a\": {\n                    [pa, i] = readPoint(svg, i);\n                    [t1, i] = readFloat(svg, i);\n                    [t2, i] = readFlag(svg, i);\n                    [t3, i] = readFlag(svg, i);\n                    [pb, i] = readPoint(svg, i);\n                    b.arcTo(pb, pa, rad(t1), t2, t3, cmd === \"a\");\n                    break;\n                }\n                case \"z\":\n                    b.closePath();\n                    break;\n                default:\n                    throw new Error(`unsupported segment type: ${c} @ pos ${i}`);\n            }\n        }\n        return b.paths;\n    }\n    catch (e) {\n        throw e instanceof Error\n            ? e\n            : new Error(`illegal char '${svg.charAt(e)}' @ ${e}`);\n    }\n};\nconst skipWS = (src, i) => {\n    const n = src.length;\n    while (i < n && WSC[src.charAt(i)])\n        i++;\n    return i;\n};\nconst readPoint = (src, index) => {\n    let x, y;\n    [x, index] = readFloat(src, index);\n    index = skipWS(src, index);\n    [y, index] = readFloat(src, index);\n    return [[x, y], index];\n};\nconst readFlag = (src, i) => {\n    i = skipWS(src, i);\n    const c = src.charAt(i);\n    return [\n        c === \"0\"\n            ? false\n            : c === \"1\"\n                ? true\n                : illegalState(`expected '0' or '1' @ pos: ${i}`),\n        i + 1,\n    ];\n};\nconst readFloat = (src, index) => {\n    index = skipWS(src, index);\n    let signOk = true;\n    let dotOk = true;\n    let expOk = false;\n    let commaOk = false;\n    let i = index;\n    for (let n = src.length; i < n; i++) {\n        const c = src.charAt(i);\n        if (\"0\" <= c && c <= \"9\") {\n            expOk = true;\n            commaOk = true;\n            signOk = false;\n            continue;\n        }\n        if (c === \"-\" || c === \"+\") {\n            if (!signOk)\n                break;\n            signOk = false;\n            continue;\n        }\n        if (c === \".\") {\n            if (!dotOk)\n                break;\n            dotOk = false;\n            continue;\n        }\n        if (c === \"e\") {\n            if (!expOk)\n                throw i;\n            expOk = false;\n            dotOk = false;\n            signOk = true;\n            continue;\n        }\n        if (c === \",\") {\n            if (!commaOk)\n                throw i;\n            i++;\n        }\n        break;\n    }\n    if (i === index) {\n        illegalState(`expected coordinate @ pos: ${i}`);\n    }\n    return [parseFloat(src.substring(index, i)), i];\n};\n\nconst plane = (normal, w, attribs) => new Plane(normalize$1(null, normal), w, attribs);\nconst planeWithPoint = (normal, p, attribs) => {\n    normal = normalize$1(null, normal);\n    return new Plane(normal, dot3(normal, p), attribs);\n};\nconst planeFrom3Points = (a, b, c, attribs) => planeWithPoint(orthoNormal3([], a, b, c), a, attribs);\n\nconst points = (pts, attribs) => new Points(pts, attribs);\nconst points3 = (pts, attribs) => new Points3(pts, attribs);\n\nconst polygon = (pts, attribs) => new Polygon(pts, attribs);\nconst star = (r, n, profile, attribs) => new Polygon(transduce(map(([i, p]) => cartesian2(null, [r * p, i * TAU])), push(), zip(normRange(n * profile.length, false), cycle(profile))), attribs);\n\nconst polyline = (pts, attribs) => new Polyline(pts, attribs);\n\n/**\n * Computes a quaternion representing the rotation `theta` around\n * `axis`.\n *\n * @param axis -\n * @param theta -\n */\nconst quatFromAxisAngle = (axis, theta) => {\n    theta *= 0.5;\n    return normalize$1([0, 0, 0, Math.cos(theta)], axis, Math.sin(theta));\n};\n\n/**\n * Returns quaternion describing the rotation from direction vector\n * `from` -> `to`. If `normalize` is true (default), first normalizes\n * the vectors (not modifying original).\n *\n * @param from -\n * @param to -\n * @param normalize -\n */\nconst alignmentQuat = (from, to, normalize = true) => {\n    if (normalize) {\n        from = normalize$1([], from);\n        to = normalize$1([], to);\n    }\n    const axis = cross3([], from, to);\n    return quatFromAxisAngle(axis, Math.atan2(mag(axis), dot3(from, to)));\n};\n\n/**\n * Multi-method. Performs matrix-matrix multiplication. If `out` is not\n * given, writes result in `a`.\n *\n * @param out -\n * @param a -\n * @param b -\n */\nconst mulM = vop(1);\n/**\n * 2x2 matrix-matrix multiplication. If `out` is not given, writes\n * result in `a`.\n *\n * @param out -\n * @param a -\n * @param b -\n */\nconst mulM22 = mulM.add(4, (out, a, b) => setC4(out || a, dotS2(a, b, 0, 0, 2), dotS2(a, b, 1, 0, 2), dotS2(a, b, 0, 2, 2), dotS2(a, b, 1, 2, 2)));\n/**\n * 2x3 matrix-matrix multiplication. If `out` is not given, writes\n * result in `a`.\n *\n * @param out -\n * @param a -\n * @param b -\n */\nconst mulM23 = mulM.add(6, (out, a, b) => setC6(out || a, dotS2(a, b, 0, 0, 2), dotS2(a, b, 1, 0, 2), dotS2(a, b, 0, 2, 2), dotS2(a, b, 1, 2, 2), dotS2(a, b, 0, 4, 2) + a[4], dotS2(a, b, 1, 4, 2) + a[5]));\n/**\n * 3x3 matrix-matrix multiplication. If `out` is not given, writes\n * result in `a`.\n *\n * @param out -\n * @param a -\n * @param b -\n */\nconst mulM33 = mulM.add(9, (out, a, b) => setC(out || a, dotS3(a, b, 0, 0, 3), dotS3(a, b, 1, 0, 3), dotS3(a, b, 2, 0, 3), dotS3(a, b, 0, 3, 3), dotS3(a, b, 1, 3, 3), dotS3(a, b, 2, 3, 3), dotS3(a, b, 0, 6, 3), dotS3(a, b, 1, 6, 3), dotS3(a, b, 2, 6, 3)));\n/**\n * 4x4 matrix-matrix multiplication. If `out` is not given, writes\n * result in `a`.\n *\n * @param out -\n * @param a -\n * @param b -\n */\nconst mulM44 = mulM.add(16, (out, a, b) => setC(out || a, dotS4(a, b, 0, 0, 4), dotS4(a, b, 1, 0, 4), dotS4(a, b, 2, 0, 4), dotS4(a, b, 3, 0, 4), dotS4(a, b, 0, 4, 4), dotS4(a, b, 1, 4, 4), dotS4(a, b, 2, 4, 4), dotS4(a, b, 3, 4, 4), dotS4(a, b, 0, 8, 4), dotS4(a, b, 1, 8, 4), dotS4(a, b, 2, 8, 4), dotS4(a, b, 3, 8, 4), dotS4(a, b, 0, 12, 4), dotS4(a, b, 1, 12, 4), dotS4(a, b, 2, 12, 4), dotS4(a, b, 3, 12, 4)));\n\n/**\n * Concatenates / multiplies given matrices in left-to-right order. A\n * minimum of 2 input matrices must be given. If `out` is null, writes\n * result into `a`.\n *\n * @param out -\n * @param a -\n * @param b -\n * @param xs -\n */\nconst concat = (out, a, b, ...xs) => xs.reduce((acc, x) => mulM(acc, acc, x), mulM(out, a, b));\n\n/**\n * Computes 2x3 matrix scale matrix and writes result to `out`. If `s`\n * is a number, scaling will be uniform.\n *\n * @param m -\n * @param s -\n */\nconst scale23 = (m, s) => ((s = isNumber(s) ? [s, s] : s), setC6(m || [], s[0], 0, 0, s[1], 0, 0));\n/**\n * Computes 4x4 matrix scale matrix and writes result to `out`. If `s`\n * is a number, scaling will be uniform.\n *\n * @param m -\n * @param s -\n */\nconst scale44 = (m, s) => ((s = isNumber(s) ? [s, s, s] : s),\n    setC(m || [], \n    // x\n    s[0], 0, 0, 0, \n    // y\n    0, s[1], 0, 0, \n    // z\n    0, 0, s[2], 0, \n    // w\n    0, 0, 0, s[3] !== undefined ? s[3] : 1));\n\n/**\n * Matrix-vector multiplication. Supports in-place modification, i.e. if\n * `out === v`.\n *\n * @param out -\n * @param m -\n * @param v -\n */\nconst mulV = vop(1);\n/**\n * Multiplies 2x2 matrix `m` with 2D vector `v`. Supports in-place\n * modification, i.e. if `out === v`.\n *\n * @param out -\n * @param m -\n * @param v -\n */\nconst mulV22 = mulV.add(4, (out, m, v) => setC2(out || v, dotS2(m, v, 0, 0, 2), dotS2(m, v, 1, 0, 2)));\n/**\n * Multiplies 2x3 matrix `m` with 2D vector `v`. Supports in-place\n * modification, i.e. if `out === v`.\n *\n * @param out -\n * @param m -\n * @param v -\n */\nconst mulV23 = mulV.add(6, (out, m, v) => setC2(out || v, dotS2(m, v, 0, 0, 2) + m[4], dotS2(m, v, 1, 0, 2) + m[5]));\n/**\n * Multiplies 3x3 matrix `m` with 3D vector `v`. Supports in-place\n * modification, i.e. if `out === v`.\n *\n * @param out -\n * @param m -\n * @param v -\n */\nconst mulV33 = mulV.add(9, (out, m, v) => setC3(out || v, dotS3(m, v, 0, 0, 3), dotS3(m, v, 1, 0, 3), dotS3(m, v, 2, 0, 3)));\n/**\n * Multiplies 4x4 matrix `m` with 4D vector `v`. Supports in-place\n * modification, i.e. if `out === v`.\n *\n * @param out -\n * @param m -\n * @param v -\n */\nconst mulV44 = mulV.add(16, (out, m, v) => setC4(out || v, dotS4(m, v, 0, 0, 4), dotS4(m, v, 1, 0, 4), dotS4(m, v, 2, 0, 4), dotS4(m, v, 3, 0, 4)));\n/**\n * Multiplies 4x4 matrix `m` with 3D vector `v` and assumes initial\n * `w=1`, i.e. the vector is interpreted as `[x,y,z,1]`. After\n * transformation applies perspective divide of the resulting XYZ\n * components. Returns `undefined` if the computed perspective divisor\n * is zero (and would cause `NaN` results).\n *\n * @param out -\n * @param m -\n * @param v -\n */\nconst mulV344 = (out, m, v) => {\n    const w = dotS3(m, v, 3, 0, 4) + m[15];\n    return w !== 0\n        ? setC3(out || v, (dotS3(m, v, 0, 0, 4) + m[12]) / w, (dotS3(m, v, 1, 0, 4) + m[13]) / w, (dotS3(m, v, 2, 0, 4) + m[14]) / w)\n        : undefined;\n};\n/**\n * Multiplies quaternion `q` with 3D vector `v`. Returns transformed\n * vector or modifies in-place if `out` is null or `v`.\n *\n * @param out -\n * @param q -\n * @param v -\n */\nconst mulVQ = (out, q, v) => {\n    const { 0: px, 1: py, 2: pz } = v;\n    const { 0: qx, 1: qy, 2: qz, 3: qw } = q;\n    const ix = qw * px + qy * pz - qz * py;\n    const iy = qw * py + qz * px - qx * pz;\n    const iz = qw * pz + qx * py - qy * px;\n    const iw = -qx * px - qy * py - qz * pz;\n    return setC3(out || v, ix * qw + iw * -qx + iy * -qz - iz * -qy, iy * qw + iw * -qy + iz * -qx - ix * -qz, iz * qw + iw * -qz + ix * -qy - iy * -qx);\n};\n\n/**\n * Constructs a 2x3 translation matrix.\n *\n * @param out -\n * @param v -\n */\nconst translation23 = (m, v) => setC6(m || [], 1, 0, 0, 1, v[0], v[1]);\n/**\n * Constructs a 4x4 translation matrix.\n *\n * @param out -\n * @param v -\n */\nconst translation44 = (m, v) => setC(m || [], 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1);\n\nfunction quad(...args) {\n    return pclike(Quad, args);\n}\nfunction quad3(...args) {\n    const attr = argAttribs(args);\n    return new Quad3(args.length === 1 ? args[0] : args, attr);\n}\nconst quadOnPlane = (plane, pos, size, attribs) => {\n    pos = closestPointPlane(pos, plane.normal, plane.w);\n    const [w, h] = isNumber(size) ? [size, size] : size;\n    const q = alignmentQuat(Z3$1, plane.normal);\n    return new Quad3([\n        [-w, -h, 0],\n        [w, -h, 0],\n        [w, h, 0],\n        [-w, h, 0],\n    ].map((p) => add3(null, mulVQ(null, q, p), pos)), attribs);\n};\n\nfunction quadratic(...args) {\n    return pclike(Quadratic, args);\n}\nconst quadraticFromLine$1 = (a, b, attribs) => new Quadratic(quadraticFromLine(a, b), attribs);\n\nconst ray = (pos, dir, attribs, normalize = true) => new Ray(pos, normalize ? normalize$1(null, dir) : dir, attribs);\n\nfunction rect(...args) {\n    return new Rect(...argsVV(args));\n}\nconst rectFromMinMax = (min, max, attribs) => new Rect(min, sub2([], max, min), attribs);\nconst rectFromCentroid = (centroid, size, attribs) => new Rect(maddN2([], size, -0.5, centroid), size, attribs);\n/**\n * Returns the intersection rect of given inputs or `undefined` if they\n * are non-overlapping.\n *\n * @param a\n * @param b\n */\nconst intersectionRect = (a, b) => {\n    const p = max2([], a.pos, b.pos);\n    const q = min2(null, add2([], a.pos, a.size), add2([], b.pos, b.size));\n    const size = max2(null, sub2(null, q, p), ZERO2);\n    return size[0] > 0 && size[1] > 0 ? new Rect(p, size) : undefined;\n};\nfunction inscribedSquare(...args) {\n    let pos, r;\n    if (args.length === 1) {\n        const c = args[0];\n        pos = c.pos;\n        r = c.r;\n    }\n    else {\n        [pos, r] = args;\n    }\n    r *= SQRT2_2;\n    return rect(subN2([], pos, r), r * 2);\n}\nfunction inscribedSquareHex(...args) {\n    let pos, l;\n    if (args.length === 1) {\n        const pts = args[0].points;\n        pos = centroid$1(pts);\n        l = dist(pts[0], pts[1]);\n    }\n    else {\n        [pos, l] = args;\n    }\n    l *= 3 - SQRT3;\n    return rect(subN2([], pos, l / 2), l);\n}\n\nconst text = (pos, body, attribs) => new Text(pos, body, attribs);\n\nfunction triangle(...args) {\n    return pclike(Triangle, args);\n}\nconst equilateralTriangle = (a, b, attribs) => new Triangle(equilateralTriangle2(a, b), attribs);\n\n/**\n * Returns the arc length / perimeter / circumference of the given\n * shape. For groups calls {@link arcLength} for each child and returns the\n * sum of results.\n *\n * Implemented for:\n *\n * - Circle\n * - Ellipse\n * - Group\n * - Line\n * - Polygon\n * - Polyline\n * - Quad\n * - Rect\n * - Triangle\n *\n */\nconst arcLength = defmulti(dispatch);\narcLength.addAll({\n    circle: ($) => TAU * $.r,\n    ellipse: ({ r: [a, b] }) => \n    // Ramanujan approximation\n    // https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n    PI * (3 * (a + b) - Math.sqrt((3 * a + b) * (3 * b + a))),\n    group: ({ children }) => children.reduce((sum, $) => sum + arcLength($), 0),\n    line: ({ points }) => dist(points[0], points[1]),\n    poly: ({ points }) => perimeter(points, points.length, true),\n    polyline: ({ points }) => perimeter(points, points.length),\n    rect: ({ size }) => 2 * (size[0] + size[1]),\n    tri: ({ points }) => dist(points[0], points[1]) +\n        dist(points[1], points[2]) +\n        dist(points[2], points[0]),\n});\narcLength.isa(\"quad\", \"poly\");\narcLength.isa(\"tri\", \"poly\");\n\n/**\n * Returns the possibly signed (unsigned by default) surface area of given\n * `shape`. For groups calls {@link area} for each child and returns sum of\n * unsigned areas.\n *\n * In general, for polygons and triangles, the sign of the result can be\n * used as indication of the shapes orientation (clockwise /\n * counterclockwise).\n *\n * For curves, lines, point clouds and rays the function returns 0.\n *\n * Implemented for:\n *\n * - AABB\n * - Circle\n * - Cubic\n * - Ellipse\n * - Group\n * - Line\n * - Plane\n * - Points\n * - Polygon\n * - Polyline\n * - Quad\n * - Quadratic\n * - Ray\n * - Rect\n * - Sphere\n * - Triangle\n *\n * @param shape - shape to operate on\n * @param signed - true, if signed area\n */\nconst area = defmulti(dispatch);\narea.add(DEFAULT, () => 0);\narea.addAll({\n    aabb: ({ size: [w, h, d] }) => 2 * (w * h + w * d + h * d),\n    arc: \n    // http://cut-the-knot.org/Generalization/Cavalieri2.shtml\n    ($) => 0.5 * Math.abs($.start - $.end) * $.r[0] * $.r[1],\n    circle: ($) => PI * $.r ** 2,\n    ellipse: ($) => PI * $.r[0] * $.r[1],\n    group: ({ children }) => children.reduce((sum, $) => sum + area($, false), 0),\n    plane: () => Infinity,\n    poly: ($, signed) => {\n        const area = polyArea2($.points);\n        return signed ? area : Math.abs(area);\n    },\n    rect: ($) => $.size[0] * $.size[1],\n    sphere: ($) => 4 * PI * $.r ** 2,\n    tri: ($, signed) => {\n        const area = 0.5 * signedArea2(...$.points);\n        return signed ? area : Math.abs(area);\n    },\n});\narea.isa(\"quad\", \"poly\");\n\nconst asPath = (src, attribs) => pathFromCubics(asCubic(src), attribs || copyAttribs(src));\n\nconst asPolyline = defmulti(dispatch);\nasPolyline.addAll({\n    cubic: ($, opts) => new Polyline(vertices($, opts)),\n    points: ($, opts) => new Polyline(vertices($, opts), copyAttribs($)),\n    path: ($, opts) => {\n        const pts = vertices($, opts);\n        $.closed && pts.push(set([], pts[0]));\n        return new Polyline(pts, copyAttribs($));\n    },\n    poly: ($, opts) => {\n        const pts = vertices($, opts);\n        pts.push(set([], pts[0]));\n        return new Polyline(pts, copyAttribs($));\n    },\n});\nasPolyline.isa(\"arc\", \"cubic\");\nasPolyline.isa(\"circle\", \"poly\");\nasPolyline.isa(\"ellipse\", \"poly\");\nasPolyline.isa(\"line\", \"points\");\nasPolyline.isa(\"polyline\", \"points\");\nasPolyline.isa(\"quad\", \"poly\");\nasPolyline.isa(\"quadratic\", \"cubic\");\nasPolyline.isa(\"rect\", \"poly\");\nasPolyline.isa(\"tri\", \"poly\");\n\n/** @internal */\nconst PROC_TAGS = {\n    \"?xml\": \"?>\\n\",\n    \"!DOCTYPE\": \">\\n\",\n    \"!ENTITY\": \">\\n\",\n    \"!ELEMENT\": \">\\n\",\n    \"!ATTLIST\": \">\\n\",\n};\n/** @internal */\nconst ENTITIES = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&apos;\",\n};\n/** @internal */\nconst RE_TAG = /^([^\\s\\.#]+)(?:#([^\\s\\.#]+))?(?:\\.([^\\s#]+))?$/;\n/** @internal */\nconst RE_ENTITY = new RegExp(`[${Object.keys(ENTITIES).join(\"\")}]`, \"g\");\n/** @internal */\nconst COMMENT = \"__COMMENT__\";\n/** @internal */\nconst CDATA = \"!CDATA\";\n/** @internal */\nconst NO_SPANS = {\n    button: 1,\n    option: 1,\n    script: 1,\n    style: 1,\n    text: 1,\n    textarea: 1,\n    title: 1,\n};\nconst tagMap = (tags) => tags.split(\" \").reduce((acc, x) => ((acc[x] = true), acc), {});\n/** @internal */\n// tslint:disable-next-line\nconst SVG_TAGS = tagMap(\"animate animateColor animateMotion animateTransform circle clipPath color-profile defs desc discard ellipse feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feDropShadow feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence filter font foreignObject g image line linearGradient marker mask metadata mpath path pattern polygon polyline radialGradient rect set stop style svg switch symbol text textPath title tref tspan use view\");\n/** @internal */\n// tslint:disable-next-line\nconst VOID_TAGS = tagMap(\"area base br col command embed hr img input keygen link meta param source stop track use wbr ?xml\");\n/** @internal */\n// tslint:disable-next-line\nconst NO_CLOSE_EMPTY = tagMap(\"animate circle ellipse line path polygon polyline rect\");\n/** @internal */\nconst ATTRIB_JOIN_DELIMS = {\n    accept: \",\",\n    sizes: \",\",\n    srcset: \",\",\n};\n\n/**\n * Takes a space separated string of existing CSS class names and merges\n * it with `val`, which is either another string of class names, an\n * object of booleans or an `IDeref` evaluating to either. Returns\n * updated class string.\n *\n * @remarks\n * If `val` evaluates to a string, it will be appended to `existing`.\n *\n * If `val` is an object, its keys are used as class names and their\n * values indicate if the class should be added or removed from the\n * existing set.\n *\n * @example\n * ```ts\n * mergeClasses(\"foo bar\", { foo: false, baz: true })\n * // \"bar baz\"\n *\n * mergeClasses(\"foo bar\", \"baz\");\n * // \"baz\"\n * ```\n *\n * @param existing\n * @param val\n */\nconst mergeClasses = (existing, val) => {\n    val = deref(val);\n    if (val == null)\n        return existing;\n    if (isString(val))\n        return existing + \" \" + val;\n    const classes = new Set(existing.split(\" \"));\n    for (let id in val) {\n        deref(val[id]) ? classes.add(id) : classes.delete(id);\n    }\n    return [...classes].join(\" \");\n};\n/**\n * Takes an attrib object and optional element ID and CSS class names from Emmet-style\n * hiccup tag, then transforms and merges definitions, returns attribs.\n *\n * @param attribs\n * @param id\n * @param classes\n */\nconst mergeEmmetAttribs = (attribs, id, classes) => {\n    id && (attribs.id = id);\n    let aclass = deref(attribs.class);\n    if (classes) {\n        classes = classes.replace(/\\./g, \" \");\n        attribs.class = aclass ? mergeClasses(classes, aclass) : classes;\n    }\n    else if (aclass) {\n        attribs.class = isString(aclass) ? aclass : mergeClasses(\"\", aclass);\n    }\n    return attribs;\n};\n\nconst css = (rules) => {\n    let css = \"\";\n    let v;\n    for (let r in rules) {\n        v = deref(rules[r]);\n        isFunction(v) && (v = v(rules));\n        v != null && (css += `${r}:${v};`);\n    }\n    return css;\n};\n\nconst escape = (x) => x.replace(RE_ENTITY, (y) => ENTITIES[y]);\n\nconst normalize = (tag) => {\n    let name = tag[0];\n    let match;\n    const hasAttribs = isPlainObject(tag[1]);\n    const attribs = hasAttribs ? Object.assign({}, tag[1]) : {};\n    if (!isString(name) || !(match = RE_TAG.exec(name))) {\n        illegalArgs(`\"${name}\" is not a valid tag name`);\n    }\n    name = match[1];\n    mergeEmmetAttribs(attribs, match[2], match[3]);\n    if (tag.length > 1) {\n        tag = tag.slice(hasAttribs ? 2 : 1).filter((x) => x != null);\n        if (tag.length > 0) {\n            return [name, attribs, tag];\n        }\n    }\n    return [name, attribs];\n};\n\n/**\n * Takes an object of RDF/XML prefixes and returns formatted string for\n * the RDFa `prefix` attribute.\n *\n * @example\n * ```ts\n * import { foaf, xsd } from \"@thi.ng/prefixes\";\n *\n * formatPrefixes({ foaf, xsd })\n * // \"foaf: http://xmlns.com/foaf/0.1/ rdf: http://www.w3.org/2001/XMLSchema#\"\n * ```\n *\n * @param prefixes -\n */\nconst formatPrefixes = (prefixes) => Object.keys(prefixes)\n    .reduce((acc, k) => (acc.push(`${k}: ${prefixes[k]}`), acc), [])\n    .join(\" \");\n\n/**\n * Recursively normalizes and serializes given tree as HTML/SVG/XML\n * string. Expands any embedded component functions with their results.\n *\n * @remarks\n * Each node of the input tree can have one of the following input\n * forms:\n *\n * ```js\n * [\"tag\", ...]\n * [\"tag#id.class1.class2\", ...]\n * [\"tag\", {other: \"attrib\"}, ...]\n * [\"tag\", {...}, \"body\", function, ...]\n * [function, arg1, arg2, ...]\n * [{render: (ctx,...) => [...]}, args...]\n * iterable\n * ```\n *\n * Tags can be defined in \"Zencoding\" convention, e.g.\n *\n * ```js\n * [\"div#foo.bar.baz\", \"hi\"] // <div id=\"foo\" class=\"bar baz\">hi</div>\n * ```\n *\n * The presence of the attributes object (2nd array index) is optional.\n * Any attribute values, incl. functions are allowed. If the latter, the\n * function is called with the full attribs object as argument and the\n * return value is used for the attribute. This allows for the dynamic\n * creation of attrib values based on other attribs. The only exception\n * to this are event attributes, i.e. attribute names starting with\n * \"on\". Function values assigned to event attributes will be omitted\n * from the output.\n *\n * ```js\n * [\"div#foo\", { bar: (attribs) => attribs.id + \"-bar\" }]\n * // <div id=\"foo\" bar=\"foo-bar\"></div>\n * ```\n *\n * The `style` attribute can ONLY be defined as string or object.\n *\n * ```js\n * [\"div\", {style: {color: \"red\", background: \"#000\"}}]\n * // <div style=\"color:red;background:#000;\"></div>\n * ```\n *\n * Boolean attribs are serialized in HTML5 syntax (present or not).\n * `null`, `undefined` or empty string attrib values are ignored.\n *\n * Any `null` or `undefined` array values (other than in head position)\n * will also be removed, unless a function is in head position.\n *\n * A function in head position of a node acts as a mechanism for\n * component composition & delayed execution. The function will only be\n * executed at serialization time. In this case the optional global\n * context object and all other elements of that node / array are passed\n * as arguments when that function is called. The return value the\n * function MUST be a valid new tree (or `undefined`).\n *\n * If the `ctx` object it'll be passed to each embedded component fns.\n * Optionally call {@link derefContext} prior to {@link serialize} to\n * auto-deref context keys with values implementing the\n * {@link @thi.ng/api#IDeref} interface.\n *\n * ```js\n * const foo = (ctx, a, b) => [\"div#\" + a, ctx.foo, b];\n *\n * serialize([foo, \"id\", \"body\"], { foo: { class: \"black\" } })\n * // <div id=\"id\" class=\"black\">body</div>\n * ```\n *\n * Functions located in other positions are called ONLY with the global\n * context arg and can return any (serializable) value (i.e. new trees,\n * strings, numbers, iterables or any type with a suitable\n * `.toString()`, `.toHiccup()` or `.deref()` implementation).\n *\n * If the optional `span` flag is true (default: false), all text\n * content will be wrapped in <span> elements (this is to ensure DOM\n * compatibility with hdom). The only elements for spans are never\n * created are listed in `NO_SPANS` in `api.ts`.\n *\n * If the optional `keys` flag is true (default: false), all elements\n * will have an autogenerated `key` attribute injected. If `span` is\n * enabled, `keys` will be enabled by default too (since in this case we\n * assume the output is meant to be compatible with\n * {@link @thi.ng/hdom# | @thi.ng/hdom}).\n *\n * hiccup & hdom control attributes (i.e. attrib names prefixed with\n * `__`) will be omitted from the output. The only control attrib\n * supported by this package is `__serialize`. If set to `false`, the\n * entire tree branch will be excluded from the output.\n *\n * Single or multiline comments can be included using the special\n * `COMMENT` tag (`__COMMENT__`) (always WITHOUT attributes!).\n *\n * ```\n * [COMMENT, \"Hello world\"]\n * // <!-- Hello world -->\n *\n * [COMMENT, \"Hello\", \"world\"]\n * <!--\n *     Hello\n *     world\n * -->\n * ```\n *\n * Currently, the only processing / DTD instructions supported are:\n *\n * - `?xml`\n * - `!DOCTYTPE`\n * - `!ELEMENT`\n * - `!ENTITY`\n * - `!ATTLIST`\n *\n * These are used as follows (attribs are only allowed for `?xml`, all\n * others only accept a body string which is taken as is):\n *\n * ```\n * [\"?xml\", { version: \"1.0\", standalone: \"yes\" }]\n * // <?xml version=\"1.0\" standalone=\"yes\"?>\n *\n * [\"!DOCTYPE\", \"html\"]\n * // <!DOCTYPE html>\n * ```\n *\n * @param tree - hiccup elements / component tree\n * @param ctx - arbitrary user context object\n * @param escape - auto-escape entities\n * @param span - use spans for text content\n * @param keys - attach key attribs\n */\nconst serialize = (tree, ctx, escape = false, span = false, keys = span, path = [0]) => _serialize(tree, ctx, escape, span, keys, path);\nconst _serialize = (tree, ctx, esc, span, keys, path) => tree == null\n    ? \"\"\n    : Array.isArray(tree)\n        ? serializeElement(tree, ctx, esc, span, keys, path)\n        : isFunction(tree)\n            ? _serialize(tree(ctx), ctx, esc, span, keys, path)\n            : implementsFunction(tree, \"toHiccup\")\n                ? _serialize(tree.toHiccup(ctx), ctx, esc, span, keys, path)\n                : isDeref(tree)\n                    ? _serialize(tree.deref(), ctx, esc, span, keys, path)\n                    : isNotStringAndIterable(tree)\n                        ? serializeIter(tree, ctx, esc, span, keys, path)\n                        : ((tree = esc ? escape(String(tree)) : String(tree)), span)\n                            ? `<span${keys ? ` key=\"${path.join(\"-\")}\"` : \"\"}>${tree}</span>`\n                            : tree;\nconst serializeElement = (tree, ctx, esc, span, keys, path) => {\n    let tag = tree[0];\n    return !tree.length\n        ? \"\"\n        : isFunction(tag)\n            ? _serialize(tag.apply(null, [ctx, ...tree.slice(1)]), ctx, esc, span, keys, path)\n            : implementsFunction(tag, \"render\")\n                ? _serialize(tag.render.apply(null, [ctx, ...tree.slice(1)]), ctx, esc, span, keys, path)\n                : tag === COMMENT\n                    ? serializeComment(tree)\n                    : tag == CDATA\n                        ? serializeCData(tree)\n                        : isString(tag)\n                            ? serializeTag(tree, ctx, esc, span, keys, path)\n                            : isNotStringAndIterable(tree)\n                                ? serializeIter(tree, ctx, esc, span, keys, path)\n                                : illegalArgs(`invalid tree node: ${tree}`);\n};\nconst serializeTag = (tree, ctx, esc, span, keys, path) => {\n    tree = normalize(tree);\n    const attribs = tree[1];\n    if (attribs.__skip || attribs.__serialize === false)\n        return \"\";\n    keys && attribs.key === undefined && (attribs.key = path.join(\"-\"));\n    const tag = tree[0];\n    const body = tree[2]\n        ? serializeBody(tag, tree[2], ctx, esc, span, keys, path)\n        : !VOID_TAGS[tag] && !NO_CLOSE_EMPTY[tag]\n            ? `></${tag}>`\n            : PROC_TAGS[tag] || \"/>\";\n    return `<${tag}${serializeAttribs(attribs, esc)}${body}`;\n};\nconst serializeAttribs = (attribs, esc) => {\n    let res = \"\";\n    for (let a in attribs) {\n        if (a.startsWith(\"__\"))\n            continue;\n        const v = serializeAttrib(attribs, a, deref(attribs[a]), esc);\n        v != null && (res += v);\n    }\n    return res;\n};\nconst serializeAttrib = (attribs, a, v, esc) => {\n    return v == null\n        ? null\n        : isFunction(v) && (/^on\\w+/.test(a) || (v = v(attribs)) == null)\n            ? null\n            : v === true\n                ? \" \" + a\n                : v === false\n                    ? null\n                    : a === \"data\"\n                        ? serializeDataAttribs(v, esc)\n                        : attribPair(a, v, esc);\n};\nconst attribPair = (a, v, esc) => {\n    v =\n        a === \"style\" && isPlainObject(v)\n            ? css(v)\n            : a === \"prefix\" && isPlainObject(v)\n                ? formatPrefixes(v)\n                : isArray(v)\n                    ? v.join(ATTRIB_JOIN_DELIMS[a] || \" \")\n                    : v.toString();\n    return v.length ? ` ${a}=\"${esc ? escape(v) : v}\"` : null;\n};\nconst serializeDataAttribs = (data, esc) => {\n    let res = \"\";\n    for (let id in data) {\n        let v = deref(data[id]);\n        isFunction(v) && (v = v(data));\n        v != null && (res += ` data-${id}=\"${esc ? escape(v) : v}\"`);\n    }\n    return res;\n};\nconst serializeBody = (tag, body, ctx, esc, span, keys, path) => {\n    if (VOID_TAGS[tag]) {\n        illegalArgs(`No body allowed in tag: ${tag}`);\n    }\n    const proc = PROC_TAGS[tag];\n    let res = proc ? \" \" : \">\";\n    span = span && !proc && !NO_SPANS[tag];\n    for (let i = 0, n = body.length; i < n; i++) {\n        res += _serialize(body[i], ctx, esc, span, keys, [...path, i]);\n    }\n    return res + (proc || `</${tag}>`);\n};\nconst serializeComment = (tree) => tree.length > 2\n    ? `\\n<!--\\n${tree\n        .slice(1)\n        .map((x) => \"    \" + x)\n        .join(\"\\n\")}\\n-->\\n`\n    : `\\n<!-- ${tree[1]} -->\\n`;\nconst serializeCData = (tree) => `<![CDATA[\\n${tree.slice(1).join(\"\\n\")}\\n]]>`;\nconst serializeIter = (iter, ctx, esc, span, keys, path) => {\n    const res = [];\n    const p = path.slice(0, path.length - 1);\n    let k = 0;\n    for (let i of iter) {\n        res.push(_serialize(i, ctx, esc, span, keys, [...p, k++]));\n    }\n    return res.join(\"\");\n};\n\n/**\n * RGB black\n */\nconst BLACK = Object.freeze([0, 0, 0, 1]);\n/**\n * RGB white\n */\nconst WHITE = Object.freeze([1, 1, 1, 1]);\n/**\n * RGB red\n */\nconst RED = Object.freeze([1, 0, 0, 1]);\n/**\n * RGB green\n */\nconst GREEN = Object.freeze([0, 1, 0, 1]);\n/**\n * RGB blue\n */\nconst BLUE = Object.freeze([0, 0, 1, 1]);\n/**\n * RGB cyan\n */\nconst CYAN = Object.freeze([0, 1, 1, 1]);\n/**\n * RGB magenta\n */\nconst MAGENTA = Object.freeze([1, 0, 1, 1]);\n/**\n * RGB yellow\n */\nconst YELLOW = Object.freeze([1, 1, 0, 1]);\n/**\n * XYZ D50 to sRGB conversion matrix\n *\n * @remarks\n * Reference:\n * http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n */\nconst XYZ_RGB_D50 = [\n    3.1338561,\n    -0.9787684,\n    0.0719453,\n    -1.6168667,\n    1.9161415,\n    -0.2289914,\n    -0.4906146,\n    0.033454,\n    1.4052427,\n];\n/**\n * XYZ D65 to sRGB conversion matrix\n *\n * @remarks\n * Reference:\n * http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n */\nconst XYZ_RGB_D65 = [\n    3.2404542,\n    -0.969266,\n    0.0556434,\n    -1.5371385,\n    1.8760108,\n    -0.2040259,\n    -0.4985314,\n    0.041556,\n    1.0572252,\n];\n/**\n * CIE Standard Illuminant D50\n */\nconst D50 = [0.96422, 1, 0.82521];\n/**\n * CIE Standard Illuminant D65\n *\n * Reference:\n * https://en.wikipedia.org/wiki/Illuminant_D65\n */\nconst D65 = [0.95047, 1, 1.08883];\n/**\n * Float value formatter\n *\n * @internal\n */\nlet FF = float(3);\n/**\n * Percentage value formatter\n *\n * @internal\n */\nlet PC = percent(3);\nconst INV8BIT = 1 / 0xff;\n\nconst CONVERSIONS = {};\nconst convert = (res, src, destMode, srcMode) => {\n    const spec = CONVERSIONS[destMode];\n    assert(!!spec, `no conversions available for ${destMode}`);\n    let $convert = spec[srcMode];\n    return $convert\n        ? $convert(res, src)\n        : CONVERSIONS.rgb[srcMode]\n            ? spec.rgb(res, CONVERSIONS.rgb[srcMode]([], src))\n            : unsupported(`can't convert: ${srcMode} -> ${destMode}`);\n};\n\nconst ensureAlpha = (x, def = 1) => x != undefined ? clamp01(x) : def;\n\n/**\n * Maps a single linear RGB channel value to sRGB.\n *\n * {@link https://en.wikipedia.org/wiki/SRGB}\n *\n * @param x - channel value\n */\nconst linearSrgb = (x) => x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;\n\n/**\n * Similar to {@link clamp}, but calls `ensureHue` to fold (instead of\n * clamping) the hue into [0,1] interval.\n *\n * @param out - result\n * @param src - source color\n * @param alpha - alpha value\n */\nconst clampH = (out, src, alpha = 1) => setC4(out || src, fract(src[0]), clamp01(src[1]), clamp01(src[2]), ensureAlpha(src[3], alpha));\n\nconst hsvHsl = (out, src) => {\n    out = clampH(out || src, src);\n    const s = out[1];\n    const v = out[2];\n    const l = ((2 - s) * v) / 2;\n    out[2] = l;\n    out[1] = l && l < 1 ? (s * v) / (l < 0.5 ? l * 2 : 2 - l * 2) : s;\n    return out;\n};\n\n/**\n * Converts linear RGB to sRGB.\n *\n * @param out - result\n * @param src - source color\n */\nconst rgbSrgb = (out, src) => setC4(out || src, linearSrgb(src[0]), linearSrgb(src[1]), linearSrgb(src[2]), ensureAlpha(src[3]));\n\nconst mulV33$1 = (out, mat, src, clampOut = false) => {\n    const x = dotS3(mat, src, 0, 0, 3);\n    const y = dotS3(mat, src, 1, 0, 3);\n    const z = dotS3(mat, src, 2, 0, 3);\n    const a = ensureAlpha(src[3]);\n    return clampOut\n        ? setC4(out || src, clamp01(x), clamp01(y), clamp01(z), a)\n        : setC4(out || src, x, y, z, a);\n};\n\nconst transform = (x) => {\n    const y = x ** 3;\n    return y > 0.008856 ? y : (x - 16 / 116) / 7.787;\n};\n/**\n * Converts Lab to XYZ using provided white point (default: {@link D50}). Also\n * see {@link labXyzD65}.\n *\n * @param out\n * @param src\n * @param white\n */\nconst labXyz = (out, src, white = D50) => {\n    const y = (src[0] + 0.16) / 1.16;\n    return setC4(out || src, transform(src[1] / 5.0 + y) * white[0], transform(y) * white[1], transform(y - src[2] / 2.0) * white[2], ensureAlpha(src[3]));\n};\n/**\n * Same as {@link labXyz}, but using hardcoded {@link D65} white point.\n *\n * @param out\n * @param src\n */\nconst labXyzD65 = (out, src) => labXyz(out, src, D65);\n\nconst lchLab = (out, src) => {\n    let { 1: c, 2: h } = src;\n    h *= TAU;\n    const a = ensureAlpha(src[3]);\n    return c > 0\n        ? setC4(out || src, src[0], Math.cos(h) * c, Math.sin(h) * c, a)\n        : setC4(out || src, src[0], 0, 0, a);\n};\n\n/**\n * Converts CIE XYZ to RGB using provided transformation/whitepoint matrix\n * (default: {@link XYZ_RGB_D50}).\n *\n * {@link https://en.wikipedia.org/wiki/CIE_1931_color_space}\n *\n * @param out - result\n * @param src - source color\n */\nconst xyzRgb = (out, src, mat = XYZ_RGB_D50) => mulV33$1(out, mat, src);\n/**\n * Same as {@link xyzRgb}, but hard coded to use {@link D65} white point (via\n * {@link XYZ_RGB_D65} matrix).\n *\n * @param out\n * @param src\n */\nconst xyzRgbD65 = (out, src) => xyzRgb(out, src, XYZ_RGB_D65);\n\n/**\n * Converts Lab to linear RGB (via XYZ) using {@link D50} white point.\n *\n * @param out\n * @param src\n */\nconst labRgb = (out, src) => xyzRgb(null, labXyz(out, src));\n/**\n * Same as {@link labRgb}, but using {@link D65} white point.\n *\n * @param out\n * @param src\n */\nconst labRgbD65 = (out, src) => xyzRgbD65(null, labXyzD65(out, src));\n\nconst hslCss = (src) => {\n    const h = FF(fract(src[0]) * 360);\n    const s = PC(clamp01(src[1]));\n    const l = PC(clamp01(src[2]));\n    const a = ensureAlpha(src[3]);\n    // TODO update to new syntax once CSS Color L4 is more widely supported\n    // https://www.w3.org/TR/css-color-4/#serializing-lab-lch\n    // https://test.csswg.org/harness/results/css-color-4_dev/grouped/ (test reports)\n    // return `hsl(${h} ${s} ${l}` + (a < 1 ? `/${FF(a)})` : \")\");\n    return a < 1 ? `hsla(${h},${s},${l},${FF(a)})` : `hsl(${h},${s},${l})`;\n};\n\nconst hsvCss = (src) => hslCss(hsvHsl([], src));\n\nconst intArgb32Css = (src) => {\n    const a = src >>> 24;\n    return a < 255\n        ? `rgba(${(src >> 16) & 0xff},${(src >> 8) & 0xff},${src & 0xff},${FF(a * INV8BIT)})`\n        : `#${U24$1(src & 0xffffff)}`;\n};\n\n/**\n * Alias for {@link intArgbAbgr}.\n */\nconst intAbgr32Argb32 = swapLane13;\n\nconst srgbCss = (src) => {\n    const r = (clamp01(src[0]) * 0xff + 0.5) | 0;\n    const g = (clamp01(src[1]) * 0xff + 0.5) | 0;\n    const b = (clamp01(src[2]) * 0xff + 0.5) | 0;\n    const a = ensureAlpha(src[3]);\n    // TODO update to `rgb(${r} ${g} ${b}/${FF(a)})` (CSS L4 syntax)\n    return a < 1\n        ? `rgba(${r},${g},${b},${FF(a)})`\n        : `#${U24$1((r << 16) | (g << 8) | b)}`;\n};\n\nconst rgbCss = (src) => srgbCss(rgbSrgb([], src));\n\n/** @internal */\nconst CSS_CONVERSIONS = {\n    abgr32: (x) => intArgb32Css(intAbgr32Argb32(x[0])),\n    argb32: (x) => intArgb32Css(x[0]),\n    hsl: hslCss,\n    hsv: hsvCss,\n    // TODO temporarily disabled until CSS L4 is officially supported in browsers\n    // currently serializing as sRGB CSS\n    // lab50: labCss,\n    // lab65: (x) => labCss(labLabD65_50([], x)),\n    // lch: lchCss,\n    lab50: (src) => srgbCss(rgbSrgb(null, labRgb([], src))),\n    lab65: (src) => srgbCss(rgbSrgb(null, labRgbD65([], src))),\n    lch: (src) => srgbCss(rgbSrgb(null, labRgb(null, lchLab([], src)))),\n    rgb: rgbCss,\n    srgb: srgbCss,\n};\n/**\n * Takes a color in one of the following formats and tries to convert it\n * to a CSS string:\n *\n * - any {@link TypedColor} instance\n * - raw sRGB(A) vector\n * - number (packed 0xaarrggbb int, MUST provide alpha channel)\n * - string (passthrough)\n *\n * @param col - source color\n */\nconst css$1 = (src) => {\n    let asCss;\n    return isString(src)\n        ? src\n        : isNumber(src)\n            ? intArgb32Css(src)\n            : src.mode\n                ? (asCss = CSS_CONVERSIONS[src.mode])\n                    ? asCss(src)\n                    : CSS_CONVERSIONS.rgb(convert([], src, \"rgb\", src.mode))\n                : srgbCss(src);\n};\n\nlet PRECISION = 2;\n/** @internal */\nconst ff = (x) => (x === (x | 0) ? x : x.toFixed(PRECISION));\n/** @internal */\nconst fpoint = (p) => ff(p[0]) + \",\" + ff(p[1]);\n/** @internal */\nconst fpoints = (pts, sep = \" \") => pts ? pts.map(fpoint).join(sep) : \"\";\n/**\n * Takes an attributes object and a number of attrib IDs whose values should be\n * formatted using {@link ff}. Mutates and returns `attribs` object.\n *\n * @param attribs\n * @param ids\n */\nconst numericAttribs = (attribs, ...ids) => {\n    let v;\n    for (let id of ids) {\n        (v = attribs[id]) != null && (attribs[id] = ff(v));\n    }\n    return attribs;\n};\n/**\n * Takes an attributes object and converts any `fill`, `stroke` or\n * transformation attributes, i.e. `transform`, `rotate`, `scale`, `translate`.\n *\n * @remarks\n * If the element has a `transform` attrib, conversion of the other attribs will\n * be skipped, else the values are assumed to be either strings or:\n *\n * - `transform`: 6-element numeric array (mat23)\n * - `translate`: 2-element array\n * - `rotate`: number (angle in radians)\n * - `scale`: number (uniform scale) or 2-elem array\n *\n * If no `transform` is given, the resulting transformation order will always be\n * TRS. Any string values given will be used as-is and therefore need to be\n * complete, e.g. `{ rotate: \"rotate(60)\" }`\n *\n * For color related attribs (`fill`, `stroke`), if given value is array-like, a\n * number or an {@link @thi.ng/color#IColor} instance, it will be converted into\n * a CSS color string using {@link @thi.ng/color#asCSS}.\n *\n * String color attribs prefixed with `$` are replaced with `url(#...)` refs\n * (used for referencing gradients).\n *\n * Returns updated attribs or `undefined` if `attribs` itself is null-ish.\n *\n * @param attribs - attributes object\n *\n * @internal\n */\nconst fattribs = (attribs) => {\n    if (!attribs)\n        return;\n    const res = ftransforms(attribs);\n    let v;\n    (v = attribs.fill) && (res.fill = fcolor(v));\n    (v = attribs.stroke) && (res.stroke = fcolor(v));\n    return res;\n};\n/**\n * Converts any transformation related attribs.\n *\n * {@link fattribs}\n *\n * @param attribs - attributes object\n *\n * @internal\n */\nconst ftransforms = (attribs) => {\n    let v;\n    if ((v = attribs.transform) ||\n        attribs.translate ||\n        attribs.scale ||\n        attribs.rotate) {\n        if (v) {\n            attribs.transform = !isString(v)\n                ? `matrix(${[...v].map(ff).join(\" \")})`\n                : v;\n            delete attribs.translate;\n            delete attribs.rotate;\n            delete attribs.scale;\n        }\n        else {\n            attribs.transform = buildTransform(attribs);\n        }\n    }\n    return attribs;\n};\nconst buildTransform = (attribs) => {\n    const tx = [];\n    let v;\n    if ((v = attribs.translate)) {\n        tx.push(isString(v) ? v : `translate(${ff(v[0])} ${ff(v[1])})`);\n        delete attribs.translate;\n    }\n    if ((v = attribs.rotate)) {\n        tx.push(isString(v) ? v : `rotate(${ff((v * 180) / Math.PI)})`);\n        delete attribs.rotate;\n    }\n    if ((v = attribs.scale)) {\n        tx.push(isString(v)\n            ? v\n            : isArrayLike(v)\n                ? `scale(${ff(v[0])} ${ff(v[1])})`\n                : `scale(${ff(v)})`);\n        delete attribs.scale;\n    }\n    return tx.join(\" \");\n};\n/**\n * Attempts to convert a single color attrib value. If `col` is prefixed with\n * `$`, the value will be converted into a `url(#...)` reference.\n *\n * {@link fattribs}\n *\n * @param col - color value\n *\n * @internal\n */\nconst fcolor = (col) => isString(col)\n    ? col[0] === \"$\"\n        ? `url(#${col.substr(1)})`\n        : col\n    : css$1(col);\nconst withoutKeys = (src, keys) => {\n    const dest = {};\n    for (let k in src) {\n        src.hasOwnProperty(k) && !keys.has(k) && (dest[k] = src[k]);\n    }\n    return dest;\n};\n\nconst circle$1 = (p, r, attribs, ...body) => [\n    \"circle\",\n    fattribs(Object.assign(Object.assign({}, attribs), { cx: ff(p[0]), cy: ff(p[1]), r: ff(r) })),\n    ...body,\n];\n\nconst ellipse$1 = (p, rx, ry, attribs, ...body) => [\n    \"ellipse\",\n    fattribs(Object.assign(Object.assign({}, attribs), { cx: ff(p[0]), cy: ff(p[1]), rx: ff(rx), ry: ff(ry) })),\n    ...body,\n];\n\nconst RE_ALPHA_COLOR = /(rgb|hsl)a\\(([a-z0-9.-]+),([0-9.%]+),([0-9.%]+),([0-9.]+)\\)/;\nconst gradient = (type, attribs, stops) => [\n    type,\n    fattribs(attribs),\n    ...stops.map(gradientStop),\n];\nconst gradientStop = ([offset, col]) => {\n    col = fcolor(col);\n    // use stop-opacity attrib for safari compatibility\n    // https://stackoverflow.com/a/26220870/294515\n    let opacity;\n    const parts = RE_ALPHA_COLOR.exec(col);\n    if (parts) {\n        col = `${parts[1]}(${parts[2]},${parts[3]},${parts[4]})`;\n        opacity = parts[5];\n    }\n    return [\"stop\", { offset, \"stop-color\": col, \"stop-opacity\": opacity }];\n};\nconst linearGradient = (id, from, to, stops, attribs) => gradient(\"linearGradient\", Object.assign(Object.assign({}, attribs), { id, x1: ff(from[0]), y1: ff(from[1]), x2: ff(to[0]), y2: ff(to[1]) }), stops);\nconst radialGradient = (id, from, to, fr, r, stops, attribs) => gradient(\"radialGradient\", Object.assign(Object.assign({}, attribs), { id, fx: ff(from[0]), fy: ff(from[1]), cx: ff(to[0]), cy: ff(to[1]), fr: ff(fr), r: ff(r) }), stops);\n\nconst image = (pos, url, attribs, ...body) => [\n    \"image\",\n    fattribs(Object.assign(Object.assign({}, attribs), { \n        // TODO replace w/ SVG2 `href` once Safari supports it\n        \"xlink:href\": url, x: ff(pos[0]), y: ff(pos[1]) })),\n    ...body,\n];\n\nconst line$1 = (a, b, attribs, ...body) => [\n    \"line\",\n    fattribs(Object.assign(Object.assign({}, attribs), { x1: ff(a[0]), y1: ff(a[1]), x2: ff(b[0]), y2: ff(b[1]) })),\n    ...body,\n];\nconst hline = (y, attribs) => line$1([-1e6, y], [1e6, y], attribs);\nconst vline = (x, attribs) => line$1([x, -1e6], [x, 1e6], attribs);\n\nconst DEG = 180 / Math.PI;\nconst path$1 = (segments, attribs, ...body) => {\n    let res = [];\n    for (let seg of segments) {\n        res.push(seg[0]);\n        switch (seg[0].toLowerCase()) {\n            case \"a\":\n                res.push([\n                    // rx\n                    ff(seg[1]),\n                    // ry\n                    ff(seg[2]),\n                    // x-axis (theta)\n                    ff(seg[3] * DEG),\n                    // xl\n                    seg[4] ? 1 : 0,\n                    // clockwise\n                    seg[5] ? 1 : 0,\n                    // target xy\n                    ff(seg[6][0]),\n                    ff(seg[6][1]),\n                ].join(\",\"));\n                break;\n            case \"h\":\n            case \"v\":\n                res.push(ff(seg[1]));\n                break;\n            case \"m\":\n            case \"l\":\n                res.push(fpoint(seg[1]));\n                break;\n            case \"z\":\n                break;\n            default:\n                res.push(fpoints(seg.slice(1), \",\"));\n        }\n    }\n    return [\"path\", fattribs(Object.assign(Object.assign({}, attribs), { d: res.join(\"\") })), ...body];\n};\n\n/**\n * Shape instancing group.\n *\n * @remarks\n * The `shape` arg can be an SVG shape `#id` defined elsewhere in the\n * document or set to `circle` or `rect` (default).\n *\n * The `size` arg is only used for the latter two shape types and\n * defines the radius or width respectively.\n *\n * @param pts - points\n * @param shape - shape type\n * @param size - point size/radius\n * @param attribs - attributes\n */\nconst points$1 = (pts, shape, size = 1, attribs, ...body) => {\n    const group = [\n        \"g\",\n        fattribs(withoutKeys(attribs, new Set([\"shape\", \"size\"]))),\n        ...body,\n    ];\n    const href = buildSymbol(group, shape, size);\n    for (let p of pts) {\n        // TODO replace w/ SVG2 `href` once Safari supports it\n        group.push([\"use\", { \"xlink:href\": href, x: ff(p[0]), y: ff(p[1]) }]);\n    }\n    return group;\n};\n/**\n * Similar to {@link points}, but takes points from a single large flat\n * buffer of coordinates with arbitrary striding.\n *\n * @remarks\n * In addition to `shape` and `size`, the following attribs can be used\n * to define the index range and strides:\n *\n * - `start` - start index (default: 0)\n * - `num` - number of points (default: buffer length/2)\n * - `cstride` - component stride (default: 1)\n * - `estride` - element stride (default: 2)\n *\n * @param pts - flat point buffer\n * @param shape - shape type\n * @param size - point size/radius\n * @param attribs - other attributes\n */\nconst packedPoints = (pts, shape, size = 1, attribs, ...body) => {\n    attribs = Object.assign({ start: 0, cstride: 1, estride: 2 }, attribs);\n    const { start, cstride, estride } = attribs;\n    let num = attribs && attribs.num != null\n        ? attribs.num\n        : ((pts.length - start) / estride) | 0;\n    const group = [\n        \"g\",\n        fattribs(withoutKeys(attribs, new Set([\"start\", \"cstride\", \"estride\", \"shape\", \"size\", \"num\"]))),\n        ...body,\n    ];\n    const href = buildSymbol(group, shape, size);\n    for (let i = start; --num >= 0; i += estride) {\n        // TODO replace w/ SVG2 `href` once Safari supports it\n        group.push([\n            \"use\",\n            { \"xlink:href\": href, x: ff(pts[i]), y: ff(pts[i + cstride]) },\n        ]);\n    }\n    return group;\n};\nconst buildSymbol = (group, shape, size) => {\n    let href;\n    if (!shape || shape[0] !== \"#\") {\n        href = \"_\" + ((Math.random() * 1e6) | 0).toString(36);\n        group.push([\"g\", { opacity: 0 }, buildShape(shape, href, size)]);\n        href = \"#\" + href;\n    }\n    else {\n        href = shape;\n    }\n    return href;\n};\nconst buildShape = (shape, id, r) => {\n    const rf = ff(r);\n    if (shape === \"circle\") {\n        return [\"circle\", { id, cx: 0, cy: 0, r: rf }];\n    }\n    const rf2 = ff(-r / 2);\n    return [\"rect\", { id, x: rf2, y: rf2, width: rf, height: rf }];\n};\n\nconst polygon$1 = (pts, attribs, ...body) => [\n    \"polygon\",\n    fattribs(Object.assign(Object.assign({}, attribs), { points: fpoints(pts) })),\n    ...body,\n];\n\nconst polyline$1 = (pts, attribs, ...body) => [\n    \"polyline\",\n    fattribs(Object.assign({ fill: \"none\", points: fpoints(pts) }, attribs)),\n    ...body,\n];\n\nconst roundedRect$1 = (p, width, height, rx, ry, attribs, ...body) => {\n    attribs = fattribs(Object.assign(Object.assign({}, attribs), { x: ff(p[0]), y: ff(p[1]), width: ff(width), height: ff(height) }));\n    if (rx > 0 || ry > 0) {\n        attribs.rx = ff(rx);\n        attribs.ry = ff(ry);\n    }\n    return [\"rect\", attribs, ...body];\n};\n\nconst XML_SVG = \"http://www.w3.org/2000/svg\";\nconst XML_XLINK = \"http://www.w3.org/1999/xlink\";\n\nconst text$1 = (p, body, attribs, ...xs) => [\n    \"text\",\n    fattribs(Object.assign(Object.assign({}, attribs), { x: ff(p[0]), y: ff(p[1]) })),\n    body,\n    ...xs,\n];\n\nconst ATTRIB_ALIASES = {\n    alpha: \"opacity\",\n    dash: \"stroke-dasharray\",\n    dashOffset: \"stroke-dashoffset\",\n    lineCap: \"stroke-linecap\",\n    lineJoin: \"stroke-linejoin\",\n    miterLimit: \"stroke-miterlimit\",\n    weight: \"stroke-width\",\n};\nconst TEXT_ALIGN = {\n    left: \"start\",\n    right: \"end\",\n    center: \"middle\",\n    start: \"start\",\n    end: \"end\",\n};\nconst BASE_LINE = {\n    top: \"text-top\",\n    bottom: \"text-bottom\",\n};\n/**\n * Takes a normalized hiccup tree of {@link @thi.ng/geom# | @thi.ng/geom} or\n * {@link @thi.ng/hdom-canvas# | @thi.ng/hdom-canvas} shape definitions and recursively\n * converts it into an hiccup flavor which is compatible for SVG\n * serialization. This conversion also involves translation & reorg of\n * various attributes. Returns new tree. The original remains untouched,\n * as will any unrecognized tree/shape nodes.\n *\n * @param tree - shape tree\n */\nconst convertTree = (tree) => {\n    if (tree == null)\n        return null;\n    if (implementsFunction(tree, \"toHiccup\")) {\n        return convertTree(tree.toHiccup());\n    }\n    const type = tree[0];\n    if (isArray(type)) {\n        return tree.map(convertTree);\n    }\n    let attribs = convertAttribs(tree[1]);\n    switch (tree[0]) {\n        case \"svg\":\n        case \"defs\":\n        case \"a\":\n        case \"g\": {\n            const res = [type, fattribs(attribs)];\n            for (let i = 2, n = tree.length; i < n; i++) {\n                const c = convertTree(tree[i]);\n                c != null && res.push(c);\n            }\n            return res;\n        }\n        case \"linearGradient\":\n            return linearGradient(attribs.id, attribs.from, attribs.to, tree[2], {\n                gradientUnits: attribs.gradientUnits || \"userSpaceOnUse\",\n                gradientTransform: attribs.gradientTransform,\n            });\n        case \"radialGradient\":\n            return radialGradient(attribs.id, attribs.from, attribs.to, attribs.r1, attribs.r2, tree[2], {\n                gradientUnits: attribs.gradientUnits || \"userSpaceOnUse\",\n                gradientTransform: attribs.gradientTransform,\n            });\n        case \"circle\":\n            return circle$1(tree[2], tree[3], attribs, ...tree.slice(4));\n        case \"ellipse\":\n            return ellipse$1(tree[2], tree[3][0], tree[3][1], attribs, ...tree.slice(4));\n        case \"rect\": {\n            const r = tree[5] || 0;\n            return roundedRect$1(tree[2], tree[3], tree[4], r, r, attribs, ...tree.slice(6));\n        }\n        case \"line\":\n            return line$1(tree[2], tree[3], attribs, ...tree.slice(4));\n        case \"hline\":\n            return hline(tree[2], attribs);\n        case \"vline\":\n            return vline(tree[2], attribs);\n        case \"polyline\":\n            return polyline$1(tree[2], attribs, ...tree.slice(3));\n        case \"polygon\":\n            return polygon$1(tree[2], attribs, ...tree.slice(3));\n        case \"path\":\n            return path$1(tree[2], attribs, ...tree.slice(3));\n        case \"text\":\n            return text$1(tree[2], tree[3], attribs, ...tree.slice(4));\n        case \"img\":\n            return image(tree[3], tree[2].src, attribs, ...tree.slice(4));\n        case \"points\":\n            return points$1(tree[2], attribs.shape, attribs.size, attribs, ...tree.slice(3));\n        case \"packedPoints\":\n            return packedPoints(tree[2], attribs.shape, attribs.size, attribs, ...tree.slice(3));\n        default:\n            return tree;\n    }\n};\nconst convertAttribs = (attribs) => {\n    const res = {};\n    if (!attribs)\n        return res;\n    // convertTransforms(res, attribs);\n    for (let id in attribs) {\n        const v = attribs[id];\n        const aid = ATTRIB_ALIASES[id];\n        if (aid) {\n            res[aid] = v;\n        }\n        else {\n            convertAttrib(res, id, v);\n        }\n    }\n    return res;\n};\nconst convertAttrib = (res, id, v) => {\n    switch (id) {\n        case \"font\": {\n            const i = v.indexOf(\" \");\n            res[\"font-size\"] = v.substr(0, i);\n            res[\"font-family\"] = v.substr(i + 1);\n            break;\n        }\n        case \"align\":\n            res[\"text-anchor\"] = TEXT_ALIGN[v];\n            break;\n        case \"baseline\":\n            res[\"dominant-baseline\"] = BASE_LINE[v] || v;\n            break;\n        case \"filter\":\n            // TODO needs to be translated into <filter> def first\n            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/filter\n            // https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter\n            break;\n        default:\n            res[id] = v;\n    }\n};\n\n/**\n * Defines an <svg> root element with default XML namespaces. By default\n * currently still defaults to SVG version to 1.1 to support Safari and other\n * legacy tooling.\n *\n * @remarks\n * If the `convert: true` attrib is given, all body elements will be\n * automatically converted using {@link convertTree}. The `convert` attrib is\n * NOT going to be serialized in the final output.\n *\n * @param attribs - attributes object\n * @param body - shape primitives\n */\nconst svg = (attribs, ...body) => {\n    attribs = fattribs(numericAttribs(Object.assign({ version: \"1.1\", xmlns: XML_SVG, \"xmlns:xlink\": XML_XLINK }, attribs), \"width\", \"height\", \"stroke-width\"));\n    if (attribs.convert) {\n        delete attribs.convert;\n        body = body.map(convertTree);\n    }\n    return [\"svg\", attribs, ...body];\n};\n\n/**\n * Takes the position and size vectors of 2\n * {@link @thi.ng/geom-api#AABBLike}s and returns 2-tuple of\n * `[pos,size]` of their union bounds.\n *\n * @param apos - bbox 1 min pos\n * @param asize - bbox1 size\n * @param bpos - bbox 2 min pos\n * @param bsize - bbox 2 size\n */\nconst unionBounds = (apos, asize, bpos, bsize) => {\n    const p = add([], apos, asize);\n    const q = add([], bpos, bsize);\n    const pos = min([], apos, bpos);\n    return [pos, sub(null, max(null, p, q), pos)];\n};\n\n/**\n * Computes the total bounds for the given shape collection, which\n * should either contain only 2D or 3D types. No mixed dimensions are\n * allowed! Currently the {@link bounds} function MUST be passed in as\n * arg to avoid circular module dependencies.\n *\n * @param shapes - input shapes\n * @param bounds - bbox function\n */\nconst collBounds = (shapes, bounds) => {\n    let n = shapes.length - 1;\n    if (n < 0)\n        return;\n    let b = bounds(shapes[n]);\n    if (!b)\n        return;\n    let { pos, size } = b;\n    for (; --n >= 0;) {\n        b = bounds(shapes[n]);\n        if (!b)\n            continue;\n        [pos, size] = unionBounds(pos, size, b.pos, b.size);\n    }\n    return [pos, size];\n};\n\nconst bounds$2 = defmulti(dispatch);\nbounds$2.addAll({\n    arc: ($) => rectFromMinMax(...bounds($.pos, $.r, $.axis, $.start, $.end)),\n    circle: ($) => new Rect(subN2([], $.pos, $.r), mulN2(null, [2, 2], $.r)),\n    cubic: ({ points }) => rectFromMinMax(...cubicBounds(points[0], points[1], points[2], points[3])),\n    ellipse: ($) => new Rect(sub2([], $.pos, $.r), mul2(null, [2, 2], $.r)),\n    group: ($) => {\n        const res = collBounds($.children, bounds$2);\n        return res ? new Rect(...res) : undefined;\n    },\n    line: ({ points: [a, b] }) => rectFromMinMax(min([], a, b), max([], a, b)),\n    path: (path) => {\n        const b = collBounds([\n            ...iterator1(comp(map((s) => s.geo), filter((s) => !!s)), path.segments),\n        ], bounds$2);\n        return b ? new Rect(...b) : undefined;\n    },\n    points: ($) => rectFromMinMax(...bounds$1($.points, set2([], MAX2), set2([], MIN2))),\n    points3: ($) => aabbFromMinMax(...bounds$1($.points, set3([], MAX3), set3([], MIN3))),\n    quadratic: ({ points }) => rectFromMinMax(...quadraticBounds(points[0], points[1], points[2])),\n    rect: ($) => $.copy(),\n    text: ($) => new Rect(set2([], $.pos), [0, 0]),\n});\nbounds$2.isa(\"aabb\", \"rect\");\nbounds$2.isa(\"poly\", \"points\");\nbounds$2.isa(\"polyline\", \"points\");\nbounds$2.isa(\"quad\", \"points\");\nbounds$2.isa(\"tri\", \"points\");\n\nconst asSvg = (...args) => args.map((x) => serialize(convertTree(x))).join(\"\");\nconst svgDoc = (attribs, ...xs) => {\n    if (xs.length > 0) {\n        if (!attribs || !attribs.viewBox) {\n            const cbounds = collBounds(xs, bounds$2);\n            if (cbounds) {\n                const [[x, y], [w, h]] = cbounds;\n                attribs = Object.assign({ width: ff(w), height: ff(h), viewBox: `${ff(x)} ${ff(y)} ${ff(w)} ${ff(h)}` }, attribs);\n            }\n        }\n    }\n    return svg(attribs, ...xs);\n};\n\nconst centroid = defmulti(dispatch);\ncentroid.addAll({\n    circle: ($, out) => set(out || [], $.pos),\n    group: ($) => {\n        const b = bounds$2($);\n        return b ? centroid(b) : undefined;\n    },\n    line: ({ points }, out) => mixN(out || [], points[0], points[1], 0.5),\n    points: ($, out) => centroid$1($.points, out),\n    plane: ($, out) => mulN(out || [], $.normal, $.w),\n    poly: ($, out) => centerOfWeight2($.points, out),\n    rect: ($, out) => maddN(out || [], $.size, 0.5, $.pos),\n    tri: ({ points }, out) => divN(null, add(null, add(out || [], points[0], points[1]), points[2]), 3),\n});\ncentroid.isa(\"arc\", \"circle\");\ncentroid.isa(\"aabb\", \"rect\");\ncentroid.isa(\"ellipse\", \"circle\");\ncentroid.isa(\"line3\", \"line\");\ncentroid.isa(\"points3\", \"points\");\ncentroid.isa(\"polyline\", \"points\");\ncentroid.isa(\"quad\", \"poly\");\ncentroid.isa(\"sphere\", \"circle\");\ncentroid.isa(\"text\", \"circle\");\ncentroid.isa(\"tri3\", \"tri\");\n\nconst translatedPoints = (pts, delta) => pts.map((x) => add([], x, delta));\nconst translatedShape = (ctor) => ($, delta) => new ctor(translatedPoints($.points, delta), copyAttribs($));\n\nconst translate = defmulti(dispatch);\ntranslate.addAll({\n    aabb: ($, delta) => new AABB(add3([], $.pos, delta), set3([], $.size), copyAttribs($)),\n    arc: ($, delta) => {\n        const a = $.copy();\n        add2(null, a.pos, delta);\n        return a;\n    },\n    circle: ($, delta) => new Circle(add2([], $.pos, delta), $.r, copyAttribs($)),\n    cubic: translatedShape(Cubic),\n    ellipse: ($, delta) => new Ellipse(add2([], $.pos, delta), set2([], $.r), copyAttribs($)),\n    group: ($, delta) => $.copyTransformed((x) => translate(x, delta)),\n    line: translatedShape(Line),\n    path: ($, delta) => new Path($.segments.map((s) => s.geo\n        ? {\n            type: s.type,\n            geo: translate(s.geo, delta),\n        }\n        : {\n            type: s.type,\n            point: add2([], s.point, delta),\n        }), copyAttribs($)),\n    points: translatedShape(Points),\n    points3: translatedShape(Points3),\n    poly: translatedShape(Polygon),\n    polyline: translatedShape(Polyline),\n    quad: translatedShape(Quad),\n    quadratic: translatedShape(Quadratic),\n    ray: ($, delta) => new Ray(add2([], $.pos, delta), $.dir, copyAttribs($)),\n    rect: ($, delta) => new Rect(add2([], $.pos, delta), set2([], $.size), copyAttribs($)),\n    sphere: ($, delta) => new Sphere(add3([], $.pos, delta), $.r, copyAttribs($)),\n    text: ($, delta) => new Text(add2([], $.pos, delta), $.body, copyAttribs($)),\n    tri: translatedShape(Triangle),\n});\n\nconst center = defmulti(dispatch);\ncenter.add(DEFAULT, ($, origin = ZERO3) => {\n    const c = centroid($);\n    return c ? translate($, submN(null, c, origin, -1)) : undefined;\n});\ncenter.addAll({\n    arc: ($, origin = ZERO2) => new Arc(set2([], origin), set2([], $.r), $.axis, $.start, $.end, $.xl, $.cw, copyAttribs($)),\n    circle: ($, origin = ZERO2) => new Circle(set2([], origin), $.r, copyAttribs($)),\n    ellipse: ($, origin = ZERO2) => new Ellipse(set2([], origin), set2([], $.r), copyAttribs($)),\n    sphere: ($, origin = ZERO3) => new Sphere(set3([], origin), $.r, copyAttribs($)),\n});\n\nconst classifyPoint = defmulti(dispatch);\nclassifyPoint.addAll({\n    circle: ($, p, eps = EPS) => classifyPointInCircle(p, $.pos, $.r, eps),\n    plane: ($, p, eps) => sign(dot($.normal, p) - $.w, eps),\n    tri: ({ points }, p, eps = EPS) => classifyPointInTriangle2(p, points[0], points[1], points[2], eps),\n});\nclassifyPoint.isa(\"sphere\", \"circle\");\n\nconst clipConvex = defmulti(dispatch);\nclipConvex.addAll({\n    group: ({ children, attribs }, boundary) => {\n        boundary = ensureVertices(boundary);\n        const clipped = [];\n        for (let c of children) {\n            const res = clipConvex(c, boundary);\n            if (res)\n                clipped.push(res);\n        }\n        return new Group(Object.assign({}, attribs), clipped);\n    },\n    line: ($, boundary) => {\n        const segments = clipLineSegmentPoly($.points[0], $.points[1], ensureVertices(boundary));\n        return segments && segments.length\n            ? new Line(segments[0], copyAttribs($))\n            : undefined;\n    },\n    poly: ($, boundary) => {\n        boundary = ensureVertices(boundary);\n        const pts = sutherlandHodgeman($.points, boundary, centroid$1(boundary));\n        return pts.length ? new Polygon(pts, copyAttribs($)) : undefined;\n    },\n    rect: ($, boundary) => {\n        boundary = ensureVertices(boundary);\n        const pts = sutherlandHodgeman(vertices($), boundary, centroid$1(boundary));\n        return pts.length ? new Polygon(pts, copyAttribs($)) : undefined;\n    },\n});\nclipConvex.isa(\"circle\", \"rect\");\nclipConvex.isa(\"ellipse\", \"rect\");\nclipConvex.isa(\"path\", \"rect\");\nclipConvex.isa(\"quad\", \"poly\");\nclipConvex.isa(\"tri\", \"poly\");\n\nconst closestPoint$1 = defmulti(dispatch);\nclosestPoint$1.addAll({\n    aabb: ($, p, out) => closestPointAABB(p, $.pos, add3([], $.pos, $.size), out),\n    arc: ($, p, out) => closestPoint(p, $.pos, $.r, $.axis, $.start, $.end, out),\n    circle: ($, p, out) => closestPointCircle(p, $.pos, $.r, out),\n    cubic: ({ points }, p, out) => closestPointCubic(p, points[0], points[1], points[2], points[3], out),\n    line: ({ points }, p, out) => closestPointSegment(p, points[0], points[1], out),\n    plane: ($, p, out) => closestPointPlane(p, $.normal, $.w, out),\n    points: ($, p, out) => closestPointArray(p, $.points, out),\n    poly: ($, p, out) => closestPointPolyline(p, $.points, true, out),\n    polyline: ($, p, out) => closestPointPolyline(p, $.points, false, out),\n    quadratic: ({ points }, p, out) => closestPointQuadratic(p, points[0], points[1], points[2], out),\n    rect: ($, p, out) => closestPointRect(p, $.pos, add2([], $.pos, $.size), out),\n});\nclosestPoint$1.isa(\"quad\", \"poly\");\nclosestPoint$1.isa(\"sphere\", \"circle\");\nclosestPoint$1.isa(\"tri\", \"poly\");\n\nconst atan2 = Math.atan2;\n/**\n * Returns array of points defining the 2D Convex Hull of `pts` using\n * the Graham Scan method.\n *\n * - {@link https://en.wikipedia.org/wiki/Graham_scan}\n * - {@link http://c.thi.ng/}\n *\n * @param pts - input points\n * @param eps - tolerance for colinear neighbor detection\n */\nconst grahamScan2 = (pts, eps = EPS) => {\n    const num = pts.length;\n    if (num <= 3)\n        return pts.slice();\n    let h = 1;\n    let i;\n    let p;\n    let q;\n    let r;\n    let rx;\n    let ry;\n    // find min YX index\n    const min = findMin(pts);\n    [rx, ry] = pts[min];\n    const sorted = [];\n    // compute & sort by polar ordering relative to min\n    for (i = 0; i < num; i++) {\n        p = pts[i];\n        sorted[i] = { p, t: atan2(p[1] - ry, p[0] - rx) };\n    }\n    sorted.sort((a, b) => (a.t !== b.t ? a.t - b.t : a.p[0] - b.p[0]));\n    const hull = [sorted[0].p];\n    for (i = 1; i < num; i++) {\n        p = hull[h - 2];\n        q = hull[h - 1];\n        r = sorted[i].p;\n        rx = r[0];\n        ry = r[1];\n        while ((h > 1 && notCCW(p[0], p[1], q[0], q[1], rx, ry, eps)) ||\n            (h === 1 && q[0] === rx && q[1] === ry)) {\n            h--;\n            q = p;\n            p = hull[h - 2];\n        }\n        hull[h++] = r;\n    }\n    hull.length = h;\n    return hull;\n};\n/**\n * Returns true, if triangle defined by ABC is NOT counter clockwise,\n * i.e. clockwise or colinear.\n *\n * {@link @thi.ng/vectors#signedArea2}\n *\n * @param ax -\n * @param ay -\n * @param bx -\n * @param by -\n * @param cx -\n * @param cy -\n */\nconst notCCW = (ax, ay, bx, by, cx, cy, eps) => (by - ay) * (cx - ax) >= (bx - ax) * (cy - ay) - eps;\n/**\n * Returns index of point with lowest YX coords.\n *\n * @param pts -\n */\nconst findMin = (pts) => {\n    let n = pts.length - 1;\n    let minID = n;\n    let [minX, minY] = pts[n];\n    let p, y;\n    for (; --n >= 0;) {\n        p = pts[n];\n        y = p[1];\n        if (y < minY || (y === minY && p[0] < minX)) {\n            minX = p[0];\n            minY = y;\n            minID = n;\n        }\n    }\n    return minID;\n};\n\nconst convexHull = defmulti(dispatch);\nconvexHull.addAll({\n    group: ($) => new Polygon(vertices($), copyAttribs($)),\n    points: ($) => new Polygon(grahamScan2($.points), copyAttribs($)),\n    tri: ($) => $.copy(),\n});\nconvexHull.isa(\"circle\", \"tri\");\nconvexHull.isa(\"ellipse\", \"tri\");\nconvexHull.isa(\"poly\", \"points\");\nconvexHull.isa(\"polyline\", \"points\");\nconvexHull.isa(\"quad\", \"points\");\nconvexHull.isa(\"rect\", \"tri\");\n\nconst edgeIterator = (vertices, closed = false) => (partition(2, 1, closed ? wrapSides(vertices, 0, 1) : vertices));\n\nconst edges = defmulti(dispatch);\nedges.addAll({\n    aabb: ($) => {\n        const [a, b, c, d, e, f, g, h] = vertices($);\n        return [\n            [a, b],\n            [b, c],\n            [c, d],\n            [d, a],\n            [e, f],\n            [f, g],\n            [g, h],\n            [h, e],\n            [a, e],\n            [b, f],\n            [c, g],\n            [d, h], // right\n        ];\n    },\n    poly: ($) => edgeIterator($.points, true),\n    polyline: ($) => edgeIterator($.points),\n    rect: ($) => edgeIterator(vertices($), true),\n});\nedges.isa(\"line\", \"polyline\");\nedges.isa(\"quad\", \"poly\");\nedges.isa(\"tri\", \"poly\");\n\nconst mapPoint = defmulti(dispatch);\nmapPoint.addAll({\n    rect: ($, p, out = []) => div(null, sub(out, p, $.pos), $.size),\n});\nmapPoint.isa(\"aabb\", \"rect\");\n\nconst transformPoints = (pts, mat, op = mulV) => (pts.forEach((p) => op(null, mat, p)), pts);\nconst transformedPoints = (pts, mat, op = mulV) => pts.map((p) => op([], mat, p));\nconst transformPointsWith = (pts, fn, op = mulV) => (pts.forEach((p) => op(null, fn(p), p)), pts);\nconst transformedPointsWith = (pts, fn, op = mulV) => pts.map((p) => op([], fn(p), p));\nconst transformedShape = (ctor) => ($, mat) => new ctor(transformedPoints($.points, mat), copyAttribs($));\nconst transformedShapePoints = (ctor) => ($, fn) => new ctor(transformedPointsWith($.points, fn), copyAttribs($));\n// 3d versions\nconst transformPoints3 = (pts, mat) => transformPoints(pts, mat, mulV344);\nconst transformedPoints3 = (pts, mat) => transformedPoints(pts, mat, mulV344);\nconst transformedPointsWith3 = (pts, fn) => transformedPointsWith(pts, fn, mulV344);\nconst transformedShape3 = (ctor) => ($, mat) => new ctor(transformedPoints3($.points, mat), copyAttribs($));\nconst transformedShapePoints3 = (ctor) => ($, fn) => new ctor(transformedPointsWith3($.points, fn), copyAttribs($));\n\n/**\n * Transforms given shape with provided matrix. Some shape types will be\n * automatically converted to other types prior to transformation because they\n * cannot be reliably represented in their original type anymore, this\n * includes:\n *\n * - Arc => Path (cubics)\n * - Circle => Path (cubics)\n * - Ellipse => Path (cubics)\n * - Rect => Polygon\n */\nconst transform$1 = defmulti(dispatch);\ntransform$1.addAll({\n    arc: ($, mat) => transform$1(asPath($), mat),\n    cubic: transformedShape(Cubic),\n    group: ($, mat) => $.copyTransformed((x) => transform$1(x, mat)),\n    line: transformedShape(Line),\n    path: ($, mat) => new Path([\n        ...map((s) => s.type === \"m\"\n            ? {\n                type: s.type,\n                point: mulV([], mat, s.point),\n            }\n            : {\n                type: s.type,\n                geo: transform$1(s.geo, mat),\n            }, $.segments),\n    ], copyAttribs($)),\n    points: transformedShape(Points),\n    points3: transformedShape3(Points3),\n    poly: transformedShape(Polygon),\n    polyline: transformedShape(Polyline),\n    quad: transformedShape(Quad),\n    quadratic: transformedShape(Quadratic),\n    rect: ($, mat) => transform$1(asPolygon($), mat),\n    text: ($, mat) => new Text(mulV([], mat, $.pos), $.body, copyAttribs($)),\n    tri: transformedShape(Triangle),\n});\ntransform$1.isa(\"circle\", \"arc\");\ntransform$1.isa(\"ellipse\", \"circle\");\n\n/**\n * Projects given point `uv` (normalized coords) into the target space\n * defined by `shape` and writes result to `out` (or returns new\n * vector). See {@link mapPoint} for reverse operation. Both functions\n * together can be used to warp points from one shape into another.\n *\n * Currently only implemented for these shape types:\n *\n * - AABB\n * - Quad\n * - Rect\n *\n * @param shape - shape to operate on\n * @param uv - point to map in UV space\n * @param out - result\n */\nconst unmapPoint = defmulti(dispatch);\nunmapPoint.addAll({\n    quad: ({ points }, uv, out = []) => mixBilinear$1(out, points[0], points[1], points[3], points[2], uv[0], uv[1]),\n    rect: ($, uvw, out = []) => madd(out, $.size, uvw, $.pos),\n});\nunmapPoint.isa(\"aabb\", \"rect\");\nunmapPoint.isa(\"quad3\", \"quad\");\n\nconst translateScale = (tmat, smat, shape, preTrans, postTrans, scale) => transform$1(shape, concat([], tmat([], postTrans), smat([], scale), tmat([], preTrans)));\nconst fitIntoBounds2 = (shape, dest) => {\n    const src = bounds$2(shape);\n    if (!src)\n        return;\n    const c = centroid(src);\n    if (!c)\n        return;\n    return translateScale(translation23, scale23, shape, neg(null, c), centroid(dest), minNonZero2(safeDiv(dest.size[0], src.size[0]), safeDiv(dest.size[1], src.size[1])));\n};\nconst fitIntoBounds3 = (shape, dest) => {\n    const src = bounds$2(shape);\n    if (!src)\n        return;\n    const c = centroid(src);\n    if (!c)\n        return;\n    return translateScale(translation44, scale44, shape, neg(null, c), centroid(dest), minNonZero3(safeDiv(dest.size[0], src.size[0]), safeDiv(dest.size[1], src.size[1]), safeDiv(dest.size[2], src.size[2])));\n};\nconst fitAllIntoBounds2 = (shapes, dest) => {\n    const sbraw = collBounds(shapes, bounds$2);\n    if (!sbraw)\n        return;\n    const src = new Rect(...sbraw);\n    const sx = safeDiv(dest.size[0], src.size[0]);\n    const sy = safeDiv(dest.size[1], src.size[1]);\n    const scale = sx > 0 ? (sy > 0 ? Math.min(sx, sy) : sx) : sy;\n    const smat = scale23([], scale);\n    const b = center(transform$1(src, smat), centroid(dest));\n    const c1 = [];\n    const c2 = [];\n    const res = [];\n    for (let i = shapes.length; --i >= 0;) {\n        const s = shapes[i];\n        const sc = centroid(s, c1);\n        if (sc) {\n            unmapPoint(b, mapPoint(src, sc), c2);\n            res.push(translateScale(translation23, scale23, s, neg(null, c1), c2, smat));\n        }\n        else {\n            res.push(s);\n        }\n    }\n    return res;\n};\n\nconst flip = defmulti(dispatch);\nflip.add(DEFAULT, ($) => $);\nflip.addAll({\n    arc: ($) => {\n        const t = $.start;\n        $.start = $.end;\n        $.end = t;\n        $.cw = !$.cw;\n        return $;\n    },\n    group: ($) => {\n        $.children.forEach(flip);\n        return $;\n    },\n    path: ($) => {\n        // TODO\n        return $;\n    },\n    points: ($) => {\n        $.points.reverse();\n        return $;\n    },\n    ray: ($) => {\n        $.dir = neg(null, $.dir);\n        return $;\n    },\n});\nflip.isa(\"cubic\", \"points\");\nflip.isa(\"line\", \"points\");\nflip.isa(\"points3\", \"points\");\nflip.isa(\"poly\", \"points\");\nflip.isa(\"polyline\", \"points\");\nflip.isa(\"quad\", \"points\");\nflip.isa(\"quadratic\", \"points\");\nflip.isa(\"tri\", \"points\");\n\nconst intersects = defmulti(dispatch2);\nintersects.addAll({\n    \"circle-circle\": (a, b) => intersectCircleCircle(a.pos, b.pos, a.r, b.r),\n    \"line-line\": ({ points: a }, { points: b }) => intersectLineLine(a[0], a[1], b[0], b[1]),\n    \"plane-plane\": (a, b) => intersectPlanePlane(a.normal, a.w, b.normal, b.w),\n    \"ray-aabb\": (ray, box) => intersectRayAABB(ray.pos, ray.dir, box.pos, box.max()),\n    \"ray-circle\": (ray, sphere) => intersectRayCircle(ray.pos, ray.dir, sphere.pos, sphere.r),\n    \"ray-plane\": (ray, plane) => intersectRayPlane(ray.pos, ray.dir, plane.normal, plane.w),\n    \"ray-poly\": (ray, poly) => intersectRayPolyline(ray.pos, ray.dir, poly.points, true),\n    \"ray-polyline\": (ray, poly) => intersectRayPolyline(ray.pos, ray.dir, poly.points, false),\n    \"ray-rect\": (ray, rect) => intersectRayRect(ray.pos, ray.dir, rect.pos, rect.max()),\n    \"rect-circle\": (rect, circle) => ({\n        type: testRectCircle(rect.pos, rect.size, circle.pos, circle.r)\n            ? IntersectionType.INTERSECT\n            : IntersectionType.NONE,\n    }),\n    \"rect-rect\": (a, b) => ({\n        type: testRectRect(a.pos, a.size, b.pos, b.size)\n            ? IntersectionType.INTERSECT\n            : IntersectionType.NONE,\n    }),\n});\nintersects.isa(`ray-sphere`, `ray-circle`);\nintersects.isa(`ray-quad`, `ray-poly`);\nintersects.isa(`ray-tri`, `ray-poly`);\nintersects.isa(`sphere-sphere`, `circle-circle`);\n\nconst offset = defmulti(dispatch);\noffset.addAll({\n    circle: ($, n) => new Circle(set2([], $.pos), Math.max($.r + n, 0)),\n    line: ({ points: [a, b], attribs }, n) => {\n        const norm = normalCW([], a, b, n);\n        return new Quad([\n            add2([], a, norm),\n            add2([], b, norm),\n            sub2([], b, norm),\n            sub2([], a, norm),\n        ], Object.assign({}, attribs));\n    },\n    rect: ($, n) => rectFromCentroid(centroid($), max2(null, addN2([], $.size, n), ZERO2), copyAttribs($)),\n});\n\nconst pointAt$1 = defmulti(dispatch);\npointAt$1.addAll({\n    arc: ($, t) => $.pointAtTheta(fit01(t, $.start, $.end)),\n    circle: ($, t) => cartesian2(null, [$.r, TAU * t], $.pos),\n    cubic: ({ points }, t) => mixCubic$1([], points[0], points[1], points[2], points[3], t),\n    ellipse: ($, t) => madd2([], cossin(TAU * t), $.r, $.pos),\n    line: ({ points }, t) => mixN2([], points[0], points[1], t),\n    poly: ($, t) => new Sampler($.points, true).pointAt(t),\n    polyline: ($, t) => new Sampler($.points).pointAt(t),\n    quadratic: ({ points }, t) => mixQuadratic([], points[0], points[1], points[2], t),\n    ray: ($, t) => pointOnRay2([], $.pos, $.dir, t),\n    ray3: ($, t) => pointOnRay3([], $.pos, $.dir, t),\n    rect: ($, t) => new Sampler(vertices($), true).pointAt(t),\n});\npointAt$1.isa(\"quad\", \"poly\");\npointAt$1.isa(\"tri\", \"poly\");\n\nconst pointInside = defmulti(dispatch);\npointInside.addAll({\n    aabb: ($, p) => pointInAABB(p, $.pos, $.size),\n    circle: ($, p) => pointInCircle(p, $.pos, $.r),\n    line: ($, p) => pointInSegment(p, $.points[0], $.points[1]),\n    points: ({ points }, p) => isInArray(p, points),\n    poly: ($, p) => pointInPolygon2(p, $.points) > 0,\n    rect: ($, p) => pointInRect(p, $.pos, $.size),\n    tri: (tri, p) => pointInTriangle2(p, ...tri.points),\n});\npointInside.isa(\"points3\", \"points\");\npointInside.isa(\"quad\", \"poly\");\npointInside.isa(\"sphere\", \"circle\");\n\nconst resample$1 = defmulti(dispatch);\nresample$1.addAll({\n    circle: ($, opts) => asPolygon($, opts),\n    poly: ($, opts) => new Polygon(resample($.points, opts, true, true), copyAttribs($)),\n    polyline: ($, opts) => new Polyline(resample($.points, opts, false, true), copyAttribs($)),\n});\nresample$1.isa(\"ellipse\", \"circle\");\nresample$1.isa(\"line\", \"polyline\");\nresample$1.isa(\"quad\", \"poly\");\nresample$1.isa(\"tri\", \"poly\");\nresample$1.isa(\"rect\", \"circle\");\n\nconst scatter = (shape, num, rnd = SYSTEM, out = []) => {\n    const b = bounds$2(shape);\n    if (!b)\n        return;\n    const mi = b.pos;\n    const mx = b.max();\n    for (; --num >= 0;) {\n        while (true) {\n            const p = randMinMax([], mi, mx, rnd);\n            if (pointInside(shape, p)) {\n                out.push(p);\n                break;\n            }\n        }\n    }\n    return out;\n};\n\nconst simplify$1 = defmulti(dispatch);\nsimplify$1.addAll({\n    path: ($, eps = 0.1) => {\n        const res = [];\n        const orig = $.segments;\n        const n = orig.length;\n        let points;\n        let lastP;\n        for (let i = 0; i < n; i++) {\n            const s = orig[i];\n            if (s.type === \"l\" || s.type === \"p\") {\n                points = points\n                    ? points.concat(vertices(s.geo))\n                    : vertices(s.geo);\n                lastP = peek(points);\n            }\n            else if (points) {\n                points.push(lastP);\n                res.push({\n                    geo: new Polyline(simplify(points, eps)),\n                    type: \"p\",\n                });\n                points = null;\n            }\n            else {\n                res.push(Object.assign({}, s));\n            }\n        }\n        if (points) {\n            points.push(lastP);\n            res.push({\n                geo: new Polyline(points),\n                type: \"p\",\n            });\n        }\n        return new Path(res, copyAttribs($));\n    },\n    poly: ($, eps = 0.1) => new Polygon(simplify($.points, eps, true), copyAttribs($)),\n    polyline: ($, eps = 0.1) => new Polyline(simplify($.points, eps), copyAttribs($)),\n});\n\nconst pointArraysAsShapes = (ctor, src, attribs) => src\n    ? [...map((pts) => new ctor(copyVectors(pts), Object.assign({}, attribs)), src)]\n    : undefined;\n\nconst splitLine = (a, b, t) => {\n    const p = mixN([], a, b, t);\n    return [\n        [a, p],\n        [set([], p), b],\n    ];\n};\n\nconst splitAt = defmulti(dispatch);\nsplitAt.addAll({\n    arc: ($, t) => {\n        const theta = fit01(t, $.start, $.end);\n        return [\n            new Arc(set([], $.pos), set([], $.r), $.axis, $.start, theta, $.xl, $.cw, copyAttribs($)),\n            new Arc(set([], $.pos), set([], $.r), $.axis, theta, $.end, $.xl, $.cw, copyAttribs($)),\n        ];\n    },\n    cubic: ({ attribs, points }, t) => cubicSplitAt(points[0], points[1], points[2], points[3], t).map((pts) => new Cubic(pts, Object.assign({}, attribs))),\n    line: ({ attribs, points }, t) => splitLine(points[0], points[1], t).map((pts) => new Line(pts, Object.assign({}, attribs))),\n    polyline: ($, t) => pointArraysAsShapes(Polyline, new Sampler($.points).splitAt(t), $.attribs),\n    quadratic: ({ attribs, points }, t) => quadraticSplitAt(points[0], points[1], points[2], t).map((pts) => new Quadratic(pts, Object.assign({}, attribs))),\n});\n\n/**\n * Similar to {@link splitAt}, but instead of taking a normalized parametric\n * split position, splits the given curve at the closest point to `p`.\n * Returns tuple of split shapes of same type as `shape`.\n *\n * Implemented for:\n *\n * - Cubic\n * - Line\n * - Polyline\n * - Quadratic\n *\n * @param shape - shape to operate on\n * @param p - split point\n */\nconst splitNearPoint = defmulti(dispatch);\nsplitNearPoint.addAll({\n    cubic: ({ points, attribs }, p) => splitCubicNearPoint(p, points[0], points[1], points[2], points[3]).map((pts) => new Cubic(pts, Object.assign({}, attribs))),\n    line: ($, p) => {\n        const t = closestT(p, $.points[0], $.points[1]) || 0;\n        return splitLine($.points[0], $.points[1], clamp01(t)).map((pts) => new Line(pts, copyAttribs($)));\n    },\n    polyline: ($, p) => pointArraysAsShapes(Polyline, new Sampler($.points).splitNear(p), $.attribs),\n    quadratic: ({ points, attribs }, p) => quadraticSplitNearPoint(p, points[0], points[1], points[2]).map((pts) => new Quadratic(pts, Object.assign({}, attribs))),\n});\n\n/**\n * {@link http://algorithmicbotany.org/papers/subgpu.sig2003.pdf}\n *\n * @param kernel - subdivision scheme\n * @param pts - source points\n * @param iter - number of iterations\n */\nconst subdivide = (pts, { fn, pre, size }, iter = 1) => {\n    while (--iter >= 0) {\n        const nump = pts.length;\n        pts = transduce(comp(partition(size, 1), mapcatIndexed((i, pts) => fn(pts, i, nump))), push(), pre ? pre(pts) : pts);\n    }\n    return pts;\n};\n\nconst subdivCurve = defmulti(dispatch);\nsubdivCurve.addAll({\n    poly: ($, kernel, iter = 1) => new Polygon(subdivide($.points, kernel, iter), copyAttribs($)),\n    polyline: ($, kernel, iter = 1) => new Polyline(subdivide($.points, kernel, iter), copyAttribs($)),\n});\n\nconst tangentAt = defmulti(dispatch);\ntangentAt.addAll({\n    circle: (_, t) => cossin(TAU * t + HALF_PI),\n    cubic: ({ points }, t) => cubicTangentAt([], points[0], points[1], points[2], points[3], t),\n    line: ({ points }) => direction([], points[0], points[1]),\n    poly: ($, t) => new Sampler($.points, true).tangentAt(t),\n    polyline: ($, t) => new Sampler($.points).tangentAt(t),\n    quadratic: ({ points }, t) => quadraticTangentAt([], points[0], points[1], points[2], t),\n    rect: ($, t) => new Sampler(vertices($), true).tangentAt(t),\n});\ntangentAt.isa(\"quad\", \"poly\");\ntangentAt.isa(\"tri\", \"poly\");\n\nfunction tessellate(...args) {\n    return transduce(scan(reducer(() => [args[0]], (acc, fn) => transduce(mapcat(fn), push(), acc))), last(), isFunction(args[1]) ? repeat$1(args[1], args[2] || 1) : args[1]);\n}\n\nconst tessellate$1 = defmulti(dispatch);\ntessellate$1.add(DEFAULT, ($, fns) => tessellate(vertices($), fns));\n\n/**\n * Transforms vertices of given shape with provided function, which is\n * being called for each vertex individually and should produce a\n * transformation matrix. Some shape types will be automatically\n * converted to other types prior to transformation because they cannot\n * be reliably represented in their original type anymore, this\n * includes:\n *\n * - Arc => Path (cubics)\n * - Circle => Path (cubics)\n * - Ellipse => Path (cubics)\n * - Rect => Polygon\n */\nconst transformVertices = defmulti(dispatch);\ntransformVertices.addAll({\n    arc: ($, fn) => transformVertices(asPolyline($), fn),\n    cubic: transformedShapePoints(Cubic),\n    group: ($, fn) => $.copyTransformed((x) => transformVertices(x, fn)),\n    line: transformedShapePoints(Line),\n    path: ($, fn) => new Path([\n        ...map((s) => s.type === \"m\"\n            ? {\n                type: s.type,\n                point: mulV([], fn(s.point), s.point),\n            }\n            : {\n                type: s.type,\n                geo: transformVertices(s.geo, fn),\n            }, $.segments),\n    ], copyAttribs($)),\n    points: transformedShapePoints(Points),\n    points3: transformedShapePoints3(Points3),\n    poly: transformedShapePoints(Polygon),\n    polyline: transformedShapePoints(Polyline),\n    quad: transformedShapePoints(Quad),\n    quadratic: transformedShapePoints(Quadratic),\n    rect: ($, fn) => transformVertices(asPolygon($), fn),\n    tri: transformedShapePoints(Triangle),\n});\ntransformVertices.isa(\"circle\", \"rect\");\ntransformVertices.isa(\"ellipse\", \"circle\");\n\nconst union = defmulti(dispatch);\nunion.addAll({\n    aabb: (a, b) => [\n        new AABB(...unionBounds(a.pos, a.size, b.pos, b.size)),\n    ],\n    rect: (a, b) => [\n        new Rect(...unionBounds(a.pos, a.size, b.pos, b.size)),\n    ],\n});\n\n/**\n * Returns the volume of given 3D shape. Returns 0 for all others.\n *\n * Currently only implemented for:\n *\n * - AABB\n * - Sphere\n */\nconst volume = defmulti(dispatch);\nvolume.add(DEFAULT, () => 0);\nvolume.addAll({\n    aabb: ({ size }) => size[0] * size[1] * size[2],\n    sphere: ($) => (4 / 3) * PI * $.r ** 3,\n});\n\nconst warpPoints = (pts, dest, src) => {\n    const res = [];\n    for (let n = pts.length, i = 0; i < n; i++) {\n        res.push(unmapPoint(dest, mapPoint(src, pts[i])));\n    }\n    return res;\n};\n\nconst withAttribs = (shape, attribs, replace = true) => {\n    shape.attribs = replace ? attribs : Object.assign(Object.assign({}, shape.attribs), attribs);\n    return shape;\n};\n\nexport { AABB, APC, Arc, Circle, Cubic, Ellipse, Group, Line, Path, PathBuilder, Plane, Points, Points3, Polygon, Polyline, Quad, Quad3, Quadratic, Ray, Rect, Sphere, Text, Triangle, aabb, aabbFromMinMax, arc, arcFrom2Points, arcLength, area, asCubic, asPath, asPolygon, asPolyline, asSvg, bounds$2 as bounds, center, centroid, circle, circleFrom2Points, circleFrom3Points, classifyPoint, clipConvex, clippedLine, closestPoint$1 as closestPoint, collBounds, convexHull, copyAttribs, copyShape, cubic, cubicFromArc$1 as cubicFromArc, cubicFromLine$1 as cubicFromLine, cubicFromQuadratic$1 as cubicFromQuadratic, edgeIterator, edges, ellipse, ensureVertices, equilateralTriangle, fitAllIntoBounds2, fitIntoBounds2, fitIntoBounds3, flip, group, inscribedAABB, inscribedSquare, inscribedSquareHex, intersectionAABB, intersectionRect, intersects, line, mapPoint, normalizedPath, offset, path, pathBuilder, pathFromCubics, pathFromSvg, pclike, plane, planeFrom3Points, planeWithPoint, pointArraysAsShapes, pointAt$1 as pointAt, pointInside, points, points3, polygon, polyline, quad, quad3, quadOnPlane, quadratic, quadraticFromLine$1 as quadraticFromLine, ray, rect, rectFromCentroid, rectFromMinMax, resample$1 as resample, roundedRect, scatter, simplify$1 as simplify, splitAt, splitLine, splitNearPoint, star, subdivCurve, svgDoc, tangentAt, tessellate$1 as tessellate, text, transform$1 as transform, transformPoints, transformPoints3, transformPointsWith, transformVertices, transformedPoints, transformedPoints3, transformedPointsWith, transformedPointsWith3, transformedShape, transformedShape3, transformedShapePoints, transformedShapePoints3, translate, translatedPoints, translatedShape, triangle, union, unionBounds, unmapPoint, vertices, volume, warpPoints, withAttribs };\n", "import { a as equiv, e as ensureArray } from '../common/ensure-array-575b2a26.js';\nimport { m as map, E as EPS } from '../common/codegen-df7bb22c.js';\nimport { d as distSq } from '../common/distsq-d74f45eb.js';\n\nconst compare = (a, b) => {\n    if (a === b) {\n        return 0;\n    }\n    if (a == null) {\n        return b == null ? 0 : -1;\n    }\n    if (b == null) {\n        return a == null ? 0 : 1;\n    }\n    if (typeof a.compare === \"function\") {\n        return a.compare(b);\n    }\n    if (typeof b.compare === \"function\") {\n        return -b.compare(a);\n    }\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\n/**\n * Generic binary heap / priority queue with customizable ordering via\n * user-supplied comparator. By default, implements min-heap ordering\n * and uses @thi.ng/compare.\n *\n * @example\n * ```ts\n * h = new Heap([20, 5, 10]);\n * h.push(15);\n *\n * h.pop(); // 5\n * h.pop(); // 10\n * h.pop(); // 15\n * h.pop(); // 20\n * h.pop(); // undefined\n * ```\n */\nclass Heap {\n    constructor(values, opts) {\n        opts = Object.assign({ compare, equiv }, opts);\n        this.compare = opts.compare;\n        this.equiv = opts.equiv;\n        this.values = [];\n        if (values) {\n            this.into(values);\n        }\n    }\n    static parentIndex(idx) {\n        return idx > 0 ? (idx - 1) >> 1 : -1;\n    }\n    static childIndex(idx) {\n        return idx >= 0 ? (idx << 1) + 1 : -1;\n    }\n    *[Symbol.iterator]() {\n        yield* this.min();\n    }\n    get length() {\n        return this.values.length;\n    }\n    copy() {\n        const h = this.empty();\n        h.values = this.values.slice();\n        return h;\n    }\n    clear() {\n        this.values.length = 0;\n    }\n    empty() {\n        return new Heap(null, { compare: this.compare });\n    }\n    peek() {\n        return this.values[0];\n    }\n    push(val) {\n        this.values.push(val);\n        this.percolateUp(this.values.length - 1);\n        return this;\n    }\n    pop() {\n        const vals = this.values;\n        const tail = vals.pop();\n        let res;\n        if (vals.length > 0) {\n            res = vals[0];\n            vals[0] = tail;\n            this.percolateDown(0);\n        }\n        else {\n            res = tail;\n        }\n        return res;\n    }\n    pushPop(val, vals = this.values) {\n        const head = vals[0];\n        if (vals.length > 0 && this.compare(head, val) <= 0) {\n            vals[0] = val;\n            val = head;\n            this.percolateDown(0, vals);\n        }\n        return val;\n    }\n    into(vals) {\n        for (let v of vals) {\n            this.push(v);\n        }\n        return this;\n    }\n    /**\n     * Calls {@link Heap.pushPop} for each given value in `vals` and\n     * returns last result (i.e. the smallest value in heap after\n     * processing all `vals`).\n     *\n     * @param vals - values to insert\n     */\n    pushPopAll(vals) {\n        let res;\n        for (let v of vals) {\n            res = this.pushPop(v);\n        }\n        return res;\n    }\n    replaceHead(val) {\n        const res = this.values[0];\n        this.values[0] = val;\n        this.percolateDown(0);\n        return res;\n    }\n    remove(val) {\n        const { values, equiv } = this;\n        for (let i = values.length; --i >= 0;) {\n            if (equiv(values[i], val)) {\n                this.values.splice(i, 1);\n                this.heapify();\n                return true;\n            }\n        }\n        return false;\n    }\n    find(val) {\n        const { values, equiv } = this;\n        for (let i = values.length; --i >= 0;) {\n            if (equiv(values[i], val)) {\n                return values[i];\n            }\n        }\n    }\n    findWith(pred) {\n        const values = this.values;\n        for (let i = values.length; --i >= 0;) {\n            if (pred(values[i]))\n                return values[i];\n        }\n    }\n    has(val) {\n        return this.find(val) !== undefined;\n    }\n    heapify(vals = this.values) {\n        for (let i = (vals.length - 1) >> 1; i >= 0; i--) {\n            this.percolateDown(i, vals);\n        }\n    }\n    /**\n     * Returns the largest `n` values (or less) in heap, based on\n     * comparator ordering.\n     *\n     * @param n - number of values\n     */\n    max(n = this.values.length) {\n        const { compare, values } = this;\n        const res = values.slice(0, n);\n        if (!n) {\n            return res;\n        }\n        this.heapify(res);\n        for (let m = values.length; n < m; n++) {\n            this.pushPop(values[n], res);\n        }\n        return res.sort((a, b) => compare(b, a));\n    }\n    /**\n     * Returns the smallest `n` values (or less) in heap, based on\n     * comparator ordering.\n     *\n     * @param n - number of values\n     */\n    min(n = this.values.length) {\n        const { compare, values } = this;\n        const res = values.slice(0, n).sort(compare);\n        if (!n) {\n            return res;\n        }\n        let x = res[n - 1], y;\n        for (let i = n, m = values.length; i < m; i++) {\n            y = values[i];\n            if (compare(y, x) < 0) {\n                res.splice(binarySearch(y, res, 0, n, compare), 0, y);\n                res.pop();\n                x = res[n - 1];\n            }\n        }\n        return res;\n    }\n    parent(n) {\n        n = Heap.parentIndex(n);\n        return n >= 0 ? this.values[n] : undefined;\n    }\n    children(n) {\n        n = Heap.childIndex(n);\n        const vals = this.values;\n        const m = vals.length;\n        if (n >= m)\n            return;\n        if (n === m - 1)\n            return [vals[n]];\n        return [vals[n], vals[n + 1]];\n    }\n    leaves() {\n        const vals = this.values;\n        if (!vals.length) {\n            return [];\n        }\n        return vals.slice(Heap.parentIndex(vals.length - 1) + 1);\n    }\n    percolateUp(i, vals = this.values) {\n        const node = vals[i];\n        const cmp = this.compare;\n        while (i > 0) {\n            const pi = (i - 1) >> 1;\n            const parent = vals[pi];\n            if (cmp(node, parent) >= 0) {\n                break;\n            }\n            vals[pi] = node;\n            vals[i] = parent;\n            i = pi;\n        }\n    }\n    percolateDown(i, vals = this.values) {\n        const n = vals.length;\n        const node = vals[i];\n        const cmp = this.compare;\n        let child = (i << 1) + 1;\n        while (child < n) {\n            const next = child + 1;\n            if (next < n && cmp(vals[child], vals[next]) >= 0) {\n                child = next;\n            }\n            if (cmp(vals[child], node) < 0) {\n                vals[i] = vals[child];\n            }\n            else {\n                break;\n            }\n            i = child;\n            child = (i << 1) + 1;\n        }\n        vals[i] = node;\n    }\n}\nconst binarySearch = (x, vals, lo, hi, cmp) => {\n    let m;\n    while (lo < hi) {\n        m = (lo + hi) >>> 1;\n        if (cmp(x, vals[m]) < 0) {\n            hi = m;\n        }\n        else {\n            lo = m + 1;\n        }\n    }\n    return lo;\n};\n\n/** @internal */\nconst CMP = (a, b) => b[0] - a[0];\n/** @internal */\nconst addResults = (fn, sel, acc) => {\n    for (let n = sel.sort(CMP).length; --n >= 0;) {\n        const s = sel[n][1];\n        s && acc.push(fn(s));\n    }\n    return acc;\n};\n/**\n * Shared `into()` impl for spatial map types.\n *\n * @param map\n * @param pairs\n * @param eps\n *\n * @internal\n */\nconst into = (map, pairs, eps) => {\n    let ok = true;\n    for (let p of pairs) {\n        ok = map.set(p[0], p[1], eps) && ok;\n    }\n    return ok;\n};\n\nclass KdNode {\n    constructor(parent, dim, key, val) {\n        this.parent = parent;\n        this.d = dim;\n        this.k = key;\n        this.v = val;\n    }\n    get height() {\n        return (1 + Math.max(this.l ? this.l.height : 0, this.r ? this.r.height : 0));\n    }\n}\n/**\n * {@link https://en.wikipedia.org/wiki/K-d_tree}\n *\n * Partially based on:\n * {@link https://github.com/ubilabs/kd-tree-javascript}\n *\n */\nclass KdTreeMap {\n    constructor(dim, pairs) {\n        this.dim = dim;\n        this._size = 0;\n        this.root = pairs ? this.buildTree(ensureArray(pairs), 0) : undefined;\n    }\n    *[Symbol.iterator]() {\n        let queue = this.root ? [this.root] : [];\n        while (queue.length) {\n            const n = queue.pop();\n            if (n) {\n                yield [n.k, n.v];\n                queue.push(n.r, n.l);\n            }\n        }\n    }\n    *keys() {\n        let queue = this.root ? [this.root] : [];\n        while (queue.length) {\n            const n = queue.pop();\n            if (n) {\n                yield n.k;\n                queue.push(n.r, n.l);\n            }\n        }\n    }\n    values() {\n        return map((p) => p[1], this);\n    }\n    get size() {\n        return this._size;\n    }\n    get height() {\n        return this.root ? this.root.height : 0;\n    }\n    get ratio() {\n        return this._size ? this.height / Math.log2(this._size) : 0;\n    }\n    copy() {\n        return new KdTreeMap(this.dim, this);\n    }\n    clear() {\n        delete this.root;\n        this._size = 0;\n    }\n    empty() {\n        return new KdTreeMap(this.dim);\n    }\n    set(key, val, eps = EPS) {\n        eps = Math.max(0, eps);\n        eps *= eps;\n        const search = (node, parent) => node\n            ? search(key[node.d] < node.k[node.d] ? node.l : node.r, node)\n            : parent;\n        let parent;\n        if (this.root) {\n            parent = nearest1(key, [eps, undefined], this.dim, this.root)[1];\n            if (parent) {\n                parent.v = val;\n                return false;\n            }\n            parent = search(this.root, undefined);\n            const dim = parent.d;\n            parent[key[dim] < parent.k[dim] ? \"l\" : \"r\"] = new KdNode(parent, (dim + 1) % this.dim, key, val);\n        }\n        else {\n            this.root = new KdNode(undefined, 0, key, val);\n        }\n        this._size++;\n        return true;\n    }\n    into(pairs, eps = EPS) {\n        return into(this, pairs, eps);\n    }\n    remove(key) {\n        const node = find(key, this.root, 0);\n        if (node) {\n            remove(node) && (this.root = undefined);\n            this._size--;\n            return true;\n        }\n        return false;\n    }\n    has(key, eps = EPS) {\n        return (!!this.root &&\n            !!nearest1(key, [eps * eps, undefined], this.dim, this.root)[1]);\n    }\n    get(key, eps = EPS) {\n        if (this.root) {\n            const node = nearest1(key, [eps * eps, undefined], this.dim, this.root)[1];\n            return node ? node.v : undefined;\n        }\n    }\n    query(q, maxDist, limit, acc) {\n        return this.doSelect(q, (x) => [x.k, x.v], maxDist, limit, acc);\n    }\n    queryKeys(q, maxDist, limit, acc) {\n        return this.doSelect(q, (x) => x.k, maxDist, limit, acc);\n    }\n    queryValues(q, maxDist, limit, acc) {\n        return this.doSelect(q, (x) => x.v, maxDist, limit, acc);\n    }\n    doSelect(q, f, maxDist, maxNum = 1, acc = []) {\n        if (!this.root)\n            return [];\n        maxDist *= maxDist;\n        if (maxNum === 1) {\n            const sel = nearest1(q, [maxDist, undefined], this.dim, this.root)[1];\n            sel && acc.push(f(sel));\n        }\n        else {\n            const nodes = new Heap([[maxDist, undefined]], {\n                compare: CMP,\n            });\n            nearest(q, nodes, this.dim, maxNum, this.root);\n            return addResults(f, nodes.values, acc);\n        }\n        return acc;\n    }\n    buildTree(points, depth, parent) {\n        const n = points.length;\n        if (n === 0) {\n            return;\n        }\n        this._size++;\n        let dim = depth % this.dim;\n        if (n === 1) {\n            return new KdNode(parent, dim, ...points[0]);\n        }\n        points.sort((a, b) => a[0][dim] - b[0][dim]);\n        const med = n >>> 1;\n        const node = new KdNode(parent, dim, ...points[med]);\n        node.l = this.buildTree(points.slice(0, med), depth + 1, node);\n        node.r = this.buildTree(points.slice(med + 1), depth + 1, node);\n        return node;\n    }\n}\n/**\n * Returns node for point or `undefined` if none found.\n *\n * @param p - point\n * @param node - tree node\n * @param epsSq - squared epsilon / tolerance\n */\nconst find = (p, node, epsSq) => {\n    if (!node)\n        return;\n    return distSq(p, node.k) <= epsSq\n        ? node\n        : find(p, p[node.d] < node.k[node.d] ? node.l : node.r, epsSq);\n};\nconst findMin = (node, dim) => {\n    if (!node)\n        return;\n    if (node.d === dim) {\n        return node.l ? findMin(node.l, dim) : node;\n    }\n    const q = node.k[dim];\n    const l = findMin(node.l, dim);\n    const r = findMin(node.r, dim);\n    let min = node;\n    if (l && l.k[dim] < q) {\n        min = l;\n    }\n    if (r && r.k[dim] < min.k[dim]) {\n        min = r;\n    }\n    return min;\n};\n/**\n * Returns true if root is to be deleted.\n *\n * @param node - tree node\n */\nconst remove = (node) => {\n    if (!node.l && !node.r) {\n        if (!node.parent) {\n            return true;\n        }\n        const parent = node.parent;\n        const pdim = parent.d;\n        parent[node.k[pdim] < parent.k[pdim] ? \"l\" : \"r\"] = undefined;\n        return;\n    }\n    let next;\n    let nextP;\n    if (node.r) {\n        next = findMin(node.r, node.d);\n        nextP = next.k;\n        remove(next);\n        node.k = nextP;\n    }\n    else {\n        next = findMin(node.l, node.d);\n        nextP = next.k;\n        remove(next);\n        node.r = node.l;\n        node.l = undefined;\n        node.k = nextP;\n    }\n};\nconst nearest = (q, acc, dims, maxNum, node) => {\n    const p = node.k;\n    const ndist = distSq(p, q);\n    if (!node.l && !node.r) {\n        collect(acc, maxNum, node, ndist);\n        return;\n    }\n    const tdist = nodeDist(node, dims, q, p);\n    let best = bestChild(node, q);\n    nearest(q, acc, dims, maxNum, best);\n    collect(acc, maxNum, node, ndist);\n    if (tdist < acc.values[0][0]) {\n        best = best === node.l ? node.r : node.l;\n        best && nearest(q, acc, dims, maxNum, best);\n    }\n};\n/**\n * Optimized version of {@link nearest} for single closest point search.\n *\n * @param q - search point\n * @param acc - accumulator\n * @param dims - dimensions\n * @param node - tree node\n */\nconst nearest1 = (q, acc, dims, node) => {\n    const p = node.k;\n    const ndist = distSq(p, q);\n    if (!node.l && !node.r) {\n        collect1(acc, node, ndist);\n        return acc;\n    }\n    const tdist = nodeDist(node, dims, q, p);\n    let best = bestChild(node, q);\n    nearest1(q, acc, dims, best);\n    collect1(acc, node, ndist);\n    if (tdist < acc[0]) {\n        best = best === node.l ? node.r : node.l;\n        best && nearest1(q, acc, dims, best);\n    }\n    return acc;\n};\nconst bestChild = (node, q) => {\n    const d = node.d;\n    return !node.r\n        ? node.l\n        : !node.l\n            ? node.r\n            : q[d] < node.k[d]\n                ? node.l\n                : node.r;\n};\nconst collect = (acc, maxNum, node, ndist) => (!acc.length || ndist < acc.peek()[0]) &&\n    (acc.length >= maxNum\n        ? acc.pushPop([ndist, node])\n        : acc.push([ndist, node]));\nconst collect1 = (acc, node, ndist) => ndist < acc[0] && ((acc[0] = ndist), (acc[1] = node));\nconst TMP = [];\nconst nodeDist = (node, dims, q, p) => {\n    for (let i = dims, d = node.d; --i >= 0;) {\n        TMP[i] = i === d ? q[i] : p[i];\n    }\n    return distSq(TMP, p);\n};\n\nclass KdTreeSet {\n    constructor(dim, keys) {\n        this.tree = new KdTreeMap(dim);\n        keys && this.into(keys);\n    }\n    [Symbol.iterator]() {\n        return this.tree.keys();\n    }\n    keys() {\n        return this.tree.keys();\n    }\n    values() {\n        return this.tree.keys();\n    }\n    get size() {\n        return this.tree.size;\n    }\n    get height() {\n        return this.tree.height;\n    }\n    get ratio() {\n        return this.tree.ratio;\n    }\n    copy() {\n        return new KdTreeSet(this.tree.dim, this);\n    }\n    clear() {\n        this.tree.clear();\n    }\n    empty() {\n        return new KdTreeSet(this.tree.dim);\n    }\n    add(key, eps) {\n        return this.tree.set(key, key, eps);\n    }\n    into(ks, eps) {\n        let ok = true;\n        for (let k of ks) {\n            ok = this.tree.set(k, k, eps) && ok;\n        }\n        return ok;\n    }\n    remove(key) {\n        return this.tree.remove(key);\n    }\n    has(key, eps) {\n        return this.tree.has(key, eps);\n    }\n    get(key, eps) {\n        return this.tree.get(key, eps);\n    }\n    query(q, maxDist, limit, acc) {\n        return this.tree.query(q, maxDist, limit, acc);\n    }\n    queryKeys(q, maxDist, limit, acc) {\n        return this.tree.queryKeys(q, maxDist, limit, acc);\n    }\n    queryValues(q, maxDist, limit, acc) {\n        return this.tree.queryKeys(q, maxDist, limit, acc);\n    }\n}\n\nexport { KdTreeSet };\n", "import { d as randNorm, S as SYSTEM } from '../common/random-15d3d7f2.js';\nimport { c as add, i as isNumber } from '../common/add-5cc35f4d.js';\nimport '../common/codegen-df7bb22c.js';\nimport '../common/set-c051c4f9.js';\n\nconst jitter = (out, a, n = 1, rnd = SYSTEM) => add(out, a, randNorm(new Array(a.length), n, rnd));\n\n/**\n * Produces a number of Poisson-disk samples based on given\n * configuration.\n *\n * @param opts -\n */\nconst samplePoisson = (_opts) => {\n    const opts = Object.assign({ rnd: SYSTEM, iter: 1, jitter: 1, quality: 500 }, _opts);\n    const { points, index, rnd, jitter: jitter$1, quality, density: _d } = opts;\n    const density = isNumber(_d) ? () => _d : _d;\n    const iter = Math.max(opts.iter, 1);\n    const samples = [];\n    let failed = 0;\n    let pos;\n    let d;\n    let i;\n    outer: for (let num = opts.max; num > 0;) {\n        pos = points(rnd);\n        d = density(pos);\n        i = iter;\n        while (i-- > 0) {\n            if (!index.has(pos, d)) {\n                index.add(pos, 0);\n                samples.push(pos);\n                failed = 0;\n                num--;\n                continue outer;\n            }\n            jitter(null, pos, jitter$1, rnd);\n        }\n        if (++failed > quality) {\n            break;\n        }\n    }\n    return samples;\n};\n\nexport { samplePoisson };\n", "import {DVMesh} from \"../_snowpack/pkg/@thi.ng/geom-voronoi.js\";\nimport * as g from \"../_snowpack/pkg/@thi.ng/geom.js\";\nimport {KdTreeSet} from \"../_snowpack/pkg/@thi.ng/geom-accel.js\";\nimport {samplePoisson} from \"../_snowpack/pkg/@thi.ng/poisson.js\";\nimport {randMinMax2} from \"../_snowpack/pkg/@thi.ng/vectors.js\";\nexport function triangulation(element) {\n  const index = new KdTreeSet(2);\n  const palette = [\"#FFF\", \"#F00\", \"#00F\", \"#28975A\", \"#1D6F42\", \"#175733\", \"#103D24\"];\n  const height = element.clientHeight;\n  const width = element.clientWidth;\n  const pts = samplePoisson({\n    index,\n    points: () => randMinMax2(null, [-width * 0.1, -height * 0.1], [width * 1.1, height * 1.1]),\n    density: 40,\n    iter: 2,\n    max: width * height / 2e3,\n    quality: 500\n  });\n  const delaunay = (points, width2, height2) => {\n    const mesh = new DVMesh(points);\n    const bounds = [[0, 0], [0, height2], [width2, height2], [width2, 0]];\n    const web = mesh.delaunay(bounds).map((p) => g.polygon(p));\n    return web;\n  };\n  const svg = g.asSvg(g.svgDoc({\n    viewBox: `0 0 ${width} ${height}`,\n    preserveAspectRatio: \"xMidYMid slice\",\n    fill: \"none\",\n    stroke: \"blue\",\n    style: `background-color: ${palette[5]}`\n  }, g.group({id: \"delaunay\", stroke: palette[4], \"stroke-width\": 0.5}, delaunay(pts, width, height))));\n  element.innerHTML = svg;\n}\n"],
  "mappings": "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",
  "names": []
}
